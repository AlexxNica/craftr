{
    "docs": [
        {
            "location": "/",
            "text": "Craftr 2.x\n\n\n\n\n\n\n\n\nNote: Craftr 2.x is different from the initial Craftr version in many ways\nand can not be used interchangibly. The latest version of Craftr 1.x can be\nfound under the \nv1.1.4-unreleased\n\ntag.\n\n\n\n\nCraftr is a meta build system based on \nPython 3\n scripts which produces\n\nNinja\n build manifests. It enforces the use of modular build definitions\nthat can be re-used easily. Craftr provides a standard library to support\nvarious programming languages and common libraries out of the box:\n\n\n\n\nC/C++ (cURL, DLib, GoogleTest, GoogleBenchmark, tiny-dnn, Qt5, SDL2, Boost, getopt)\n\n\nCython\n\n\nC#\n\n\nJava\n\n\nVala\n\n\n\n\nAdditional links:\n\n\n\n\nDocumentation\n\n\nGetting Started\n\n\nCraftr 2.x Wiki\n\n\n\n\nFeatures\n\n\n\n\n[x] Moduler build scripts (Craftr packages) with dependency management\n\n\n[x] Uses \npkg-config\n where available, otherwise (eg. on Windows) the source\n      code will be downloaded and compiled\n\n\n[x] Tasks allow to embed actual Python functions into the build graph\n\n\n[ ] Package manager (hosted on \nCraftr.net\n)\n\n\n[ ] Dependency-version lockfiles\n\n\n\n\nContributions\n\n\nCraftr is a one-man-show and an immature piece of software. I am happy about\nevery contribution and feedback, be it questions, criticism, feature requests,\nbug reports or pull requests!\n\n\nI would love to see Craftr used by more people. If you think it's worth to\ngive it a shot, don't hesitate to ask if you're getting stuck!\n\n\nIssue Tracker: https://github.com/craftr-build/craftr/issues\nTwitter: \n@rosensteinn\n \n@craftr_build\n\n\nInstallation\n\n\nCraftr 2.x does not have a stable release yet, though the \n2.0.0.devx\n tags\nare already available on PyPI. If you do not explicitly specify the version\nnumber, Pip will install Craftr 1.x.\n\n\n$ pip install craftr-build==2.0.0.dev5\n\n\n\nTo get the cutting edge development version, I suggest installing Craftr\nfrom the Git repository into a virtualenv.\n\n\n$ virtualenv -p python3 env && source env/bin/activate\n$ git clone https://github.com/craftr-build/craftr.git -b development\n$ cd craftr\n$ pip install -e .\n\n\n\nRequirements\n\n\n\n\nNinja\n 1.7.1 or newer\n\n\nPython\n 3.4, 3.5\n\n\n\n\nPython\n\n\n\n\ncolorama\n (optional, Windows)\n\n\nglob2\n\n\njsonschema\n\n\nninja_syntax\n\n\nnr\n\n\npy-require\n\n\ntermcolor\n (optional)\n\n\nwerkzeug\n\n\n\n\nLicense\n\n\nThe Craftr build system\nCopyright (C) 2016  Niklas Rosenstein\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\nFor more information, see the \nLICENSE.txt\n file.",
            "title": "Home"
        },
        {
            "location": "/#craftr-2x",
            "text": "Note: Craftr 2.x is different from the initial Craftr version in many ways\nand can not be used interchangibly. The latest version of Craftr 1.x can be\nfound under the  v1.1.4-unreleased \ntag.   Craftr is a meta build system based on  Python 3  scripts which produces Ninja  build manifests. It enforces the use of modular build definitions\nthat can be re-used easily. Craftr provides a standard library to support\nvarious programming languages and common libraries out of the box:   C/C++ (cURL, DLib, GoogleTest, GoogleBenchmark, tiny-dnn, Qt5, SDL2, Boost, getopt)  Cython  C#  Java  Vala   Additional links:   Documentation  Getting Started  Craftr 2.x Wiki",
            "title": "Craftr 2.x"
        },
        {
            "location": "/#features",
            "text": "[x] Moduler build scripts (Craftr packages) with dependency management  [x] Uses  pkg-config  where available, otherwise (eg. on Windows) the source\n      code will be downloaded and compiled  [x] Tasks allow to embed actual Python functions into the build graph  [ ] Package manager (hosted on  Craftr.net )  [ ] Dependency-version lockfiles",
            "title": "Features"
        },
        {
            "location": "/#contributions",
            "text": "Craftr is a one-man-show and an immature piece of software. I am happy about\nevery contribution and feedback, be it questions, criticism, feature requests,\nbug reports or pull requests!  I would love to see Craftr used by more people. If you think it's worth to\ngive it a shot, don't hesitate to ask if you're getting stuck!  Issue Tracker: https://github.com/craftr-build/craftr/issues\nTwitter:  @rosensteinn   @craftr_build",
            "title": "Contributions"
        },
        {
            "location": "/#installation",
            "text": "Craftr 2.x does not have a stable release yet, though the  2.0.0.devx  tags\nare already available on PyPI. If you do not explicitly specify the version\nnumber, Pip will install Craftr 1.x.  $ pip install craftr-build==2.0.0.dev5  To get the cutting edge development version, I suggest installing Craftr\nfrom the Git repository into a virtualenv.  $ virtualenv -p python3 env && source env/bin/activate\n$ git clone https://github.com/craftr-build/craftr.git -b development\n$ cd craftr\n$ pip install -e .",
            "title": "Installation"
        },
        {
            "location": "/#requirements",
            "text": "Ninja  1.7.1 or newer  Python  3.4, 3.5",
            "title": "Requirements"
        },
        {
            "location": "/#python",
            "text": "colorama  (optional, Windows)  glob2  jsonschema  ninja_syntax  nr  py-require  termcolor  (optional)  werkzeug",
            "title": "Python"
        },
        {
            "location": "/#license",
            "text": "The Craftr build system\nCopyright (C) 2016  Niklas Rosenstein\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.  For more information, see the  LICENSE.txt  file.",
            "title": "License"
        },
        {
            "location": "/changes/",
            "text": "v2.0.0.dev6\n\n\nAPI Changes\n\n\n\n\nadd \npkg_config(static = False)\n parameter\n\n\nadd \npkg_config()\n, \nexternal_file()\n and \nexternal_archive()\n to \ncraftr/defaults.py\n\n\nadd \nglob(ignore_false_excludes=False)\n parameter\n\n\nadd \nBaseLogger.flush()\n method\n\n\nadd \ncraftr.utils.path.getmtime()\n and \n.getimtime()\n\n\nadd \nwrite_response_file(suffix='')\n parameter\n\n\nadd \nDefault\n singleton to built-in namespace\n\n\nadd \ngentask()\n and \ntask()\n built-in functions (see #163)\n\n\nchange \nTarget\n objects can now be passed to the \nframeworks = [...]\n argument\n  of target generators that use the \nTargetBuilder\n class. These input targets\n  will automatically added to the implicit dependencies and their frameworks\n  be added\n\n\nchange \nTool\n objects can now be passed into the \ncommands = [[...]]\n argument\n  of targets generators\n\n\nchange \npath.norm()\n now makes sure that path is lowercased on Windows\n\n\nchange \nload_file()\n now adds the loaded file to \nModule.dependent_files\n\n\nrename \nload_module()\n to \nload()\n, using the old name displays a warning\n\n\n\n\nLibrary Changes\n\n\n\n\nadd \ncraftr.lib.sdl2\n (tested on Windows only)\n\n\nadd \ncraftr.lib.zlib\n (tested on Windows only)\n\n\nadd \nuic()\n and \nmoc()\n target generators to \ncraftr.lib.qt5\n (tested on Windows only)\n\n\nadd support for \nsource_directory\n argument in \ncxx.c_compile()\n and \ncxx.cpp_compile()\n\n  (actually implemented in \ncraftr.lang.cxx.common\n and \ncraftr.lang.cxx.msvc\n), see #154\n\n\nadd \ncraftr.lang.csharp:compile()\n to be used for unstarred import, and add docstrings\n\n\nadd \nexflags\n option to \ncraftr.lang.cxx.common\n module (see #152)\n\n\nchange \ncraftr.lib.cURLpp\n always requires RTTI enabled\n\n\nchange \ncraftr.lang.cxx.msvc\n now adds the static input library generated for DLLs to the outputs\n\n\nchange MSVC \ncompile()\n now supports response-files for long list of includes\n\n\n\n\nBehaviour Changes\n\n\n\n\nExperimental change not raising an exception in \ncraftr/core/build.py\n inside\n  \nreplace_argument_inout_vars()\n when multiple outputs are specified to support\n  the previously mentioned change\n\n\nUpdate verbose logging behaviour when the same module was detected twice\n\n\nBuild-directory is now removed again if nothing was exported (eg. when\n  using \ncraftr build\n without formerly exporting the build files)\n\n\nOutput before Ninja is executed is now flushed to make sure all data is\n  flushed to the terminal before Ninja outputs to the pipe\n\n\nWhen using \ncraftr build\n, Craftr now checks if any of the files that generated\n  the build data (ie. manifests and Craftrfiles) have changed since the build\n  files was generated and notifies the user in that case (see #162)\n\n\ncraftr.core.logging.DefaultLogger\n now logs the module and line number from\n  which the log occurred, padded to the right side of the terminal\n\n\nCraftr now exports a variable \nCraftr_run_command\n into the Ninja manifest\n\n\nFix invalid Ninja manifests generated with foreach Targets with no inputs (see #151)\n\n\n\n\nInternal API Changes\n\n\n\n\nadd \ncraftr.core.session.Module.current_line\n property\n\n\nadd \nModule.scriptfile\n property\n\n\nadd \nModule.dependent_files\n attribute\n\n\nadd \nManifest.filename\n attribute\n\n\nadd \ncraftr.core.build.Graph.add_task()\n and \n.tasks\n members\n\n\nadd \ncraftr.core.build.Task\n class\n\n\nchange \nManifest.parse()\n no longer accepts a file-like object\n\n\n\n\nCommand-line Changes\n\n\n\n\nadd \n-P/--project-dir\n parameters to \ncraftr\n\n\nadd \ncraftr options [-m MODULE] [-r] [-d]\n command (see #166)\n\n\nadd \ncraftr deptree [-m MODULE]\n command (see #166)\n\n\nadd \ncraftr help [name]\n command (see #167)\n\n\nfix \ncraftr run\n command\n\n\nadd \n[task] [task_args...]\n arguments to \ncraftr run\n (for internal use mostly)",
            "title": "Changelog"
        },
        {
            "location": "/changes/#v200dev6",
            "text": "API Changes   add  pkg_config(static = False)  parameter  add  pkg_config() ,  external_file()  and  external_archive()  to  craftr/defaults.py  add  glob(ignore_false_excludes=False)  parameter  add  BaseLogger.flush()  method  add  craftr.utils.path.getmtime()  and  .getimtime()  add  write_response_file(suffix='')  parameter  add  Default  singleton to built-in namespace  add  gentask()  and  task()  built-in functions (see #163)  change  Target  objects can now be passed to the  frameworks = [...]  argument\n  of target generators that use the  TargetBuilder  class. These input targets\n  will automatically added to the implicit dependencies and their frameworks\n  be added  change  Tool  objects can now be passed into the  commands = [[...]]  argument\n  of targets generators  change  path.norm()  now makes sure that path is lowercased on Windows  change  load_file()  now adds the loaded file to  Module.dependent_files  rename  load_module()  to  load() , using the old name displays a warning   Library Changes   add  craftr.lib.sdl2  (tested on Windows only)  add  craftr.lib.zlib  (tested on Windows only)  add  uic()  and  moc()  target generators to  craftr.lib.qt5  (tested on Windows only)  add support for  source_directory  argument in  cxx.c_compile()  and  cxx.cpp_compile() \n  (actually implemented in  craftr.lang.cxx.common  and  craftr.lang.cxx.msvc ), see #154  add  craftr.lang.csharp:compile()  to be used for unstarred import, and add docstrings  add  exflags  option to  craftr.lang.cxx.common  module (see #152)  change  craftr.lib.cURLpp  always requires RTTI enabled  change  craftr.lang.cxx.msvc  now adds the static input library generated for DLLs to the outputs  change MSVC  compile()  now supports response-files for long list of includes   Behaviour Changes   Experimental change not raising an exception in  craftr/core/build.py  inside\n   replace_argument_inout_vars()  when multiple outputs are specified to support\n  the previously mentioned change  Update verbose logging behaviour when the same module was detected twice  Build-directory is now removed again if nothing was exported (eg. when\n  using  craftr build  without formerly exporting the build files)  Output before Ninja is executed is now flushed to make sure all data is\n  flushed to the terminal before Ninja outputs to the pipe  When using  craftr build , Craftr now checks if any of the files that generated\n  the build data (ie. manifests and Craftrfiles) have changed since the build\n  files was generated and notifies the user in that case (see #162)  craftr.core.logging.DefaultLogger  now logs the module and line number from\n  which the log occurred, padded to the right side of the terminal  Craftr now exports a variable  Craftr_run_command  into the Ninja manifest  Fix invalid Ninja manifests generated with foreach Targets with no inputs (see #151)   Internal API Changes   add  craftr.core.session.Module.current_line  property  add  Module.scriptfile  property  add  Module.dependent_files  attribute  add  Manifest.filename  attribute  add  craftr.core.build.Graph.add_task()  and  .tasks  members  add  craftr.core.build.Task  class  change  Manifest.parse()  no longer accepts a file-like object   Command-line Changes   add  -P/--project-dir  parameters to  craftr  add  craftr options [-m MODULE] [-r] [-d]  command (see #166)  add  craftr deptree [-m MODULE]  command (see #166)  add  craftr help [name]  command (see #167)  fix  craftr run  command  add  [task] [task_args...]  arguments to  craftr run  (for internal use mostly)",
            "title": "v2.0.0.dev6"
        },
        {
            "location": "/getting-started/",
            "text": "Note\n: The example we create in this tutorial can also be found in the\n\nexamples/examples.c\n folder.\n\n\n\n\nEvery project that is compiled with Craftr needs at least a manifest and a\nbuild script. Craftr provides a convenient way to generate a template for you.\nChoose your project directory and run the following command:\n\n\n$ craftr startpackage examples.c .\n$ ls\nCraftrfile  manifest.json\n$ cat Craftrfile\n# examples.c\n$ cat manifest.json\n{\n  \"name\": \"examples.c\",\n  \"version\": \"1.0.0\",\n  \"author\": \"\",\n  \"url\": \"\",\n  \"dependencies\": {},\n  \"options\": {}\n}\n\n\n\nWe're going to compile some C source files into an executable program. For\nthat we need the \ncraftr.lang.cxx\n package that provides us with a\ncross-platform interface to compile C and C++ source code. Open the\n\nmanifest.json\n and add \ncraftr.lang.cxx\n to the dependencies.\n\n\n$ cat manifest.json\n{\n  \"name\": \"examples.c\",\n  \"version\": \"1.0.0\",\n  \"author\": \"\",\n  \"url\": \"\",\n  \"dependencies\": {\n    \"craftr.lang.cxx\": \"1.x\"\n  },\n  \"options\": {}\n}\n\n\n\n\n\n\nThe \n\"1.x\"\n part is a version selector that specifies the version of the\npackage that we depend on. We use \n1.x\n to denote that we accept any version\nwhich a major version number of \n1\n. For more information on version\nselectors, check out the \nVersionSelector\n documentation\n.\n\n\n\n\nNow let's assume we have the following two C source files in our project\ndirectory as well.\n\n\n$ cat src/main.c\n\nextern void say_hello(char const* name, char const* weather);\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    printf(\"error: usage: %s name weather\\n\");\n    return 0;\n  }\n  say_hello(argv[1], argv[2]);\n  return 0;\n}\n\n$ cat src/hello.c\n\n#include <stdio.h>\n\nvoid say_hello(char const* name, char const* weather) {\n  printf(\"Hello, %s. You are facing a %s day\\n\", name, weather);\n}\n\n\n\n\nWe want our build script to compile these two files into object files and then\nlink them together into an executable. Additionally, the build script should\nallow us to make a test run of the program.\n\n\n$ cat Craftrfile\n# examples.c\n\nfrom os import environ\nload_module('craftr.lang.cxx.*')\n\nprogram = cxx_binary(\n  inputs = c_compile(sources = glob(['src/*.c'])),\n  output = 'main'\n)\n\nrun = runtarget(program, environ.get('USERNAME', 'John'), \"sunny\")\n\n\n\n\nAnd that's it. To compile our program, we first need to export a Ninja build\nmanifest, then we can build it. Our \nrun\n target is explicit by default, meaning\nthat Ninja will not run it unless it is specified as an input or specified as\na target to build on the command-line.\n\n\n$ craftr export\ncraftr.lang.cxx: loading \"craftr.lang.cxx.msvc\" (with craftr.lang.cxx.msvc.toolkit=\"\")\ncraftr.lang.cxx:   cxc.name=\"msvc\"\ncraftr.lang.cxx:   cxc.target_arch=\"x64\"\ncraftr.lang.cxx:   cxc.version=\"19.00.23918\"\n$ craftr build\n[1/3] msvc compile (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\obj\\src\\main.obj)\n[2/3] msvc compile (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\obj\\src\\hello.obj)\n[3/3] msvc link (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\main.exe)\n$ craftr build run\n[0/1] C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\main.exe niklas sunny\nHello, niklas. You are facing a sunny day",
            "title": "Getting Started"
        },
        {
            "location": "/config/",
            "text": "Configuration values in Craftr are stored in the \nSession.options\n dictionary.\nThere are those options that are defined in Craftr packages and are automatically\nvalidated, but they are not limited by these definitions.\n\n\nNote that options that are not listed in Craftr package manifests do \nnot\n\nhave the \ninheriting\n behaviour, thus the full qualified option name must\nbe defined.\n\n\nOptions\n\n\ncraftr.ninja\n\n\nThe path or name of the Ninja executable to invoke. Defaults to the \nNINJA\n\nenvironment variable or simply \nninja\n.\n\n\nConfiguring\n\n\nOn the command-line, you can use the \n-d/--option\n argument to set options.\nThese options override every option read from configuration files. Alternatively,\nyou can specify one or more configuration files to load with the \n-c/--config\n\nargument. If none are specified, the file \n.craftrconfig\n in the current working\ndirectory is loaded if it exists.\n\n\nIf present, the file \n.craftrconfig\n in the users home directory will always\nbe loaded.\n\n\nConfiguration files are simple \n.ini\n files with two additions:\n\n\nInclude configuration files\n\n\nA configuration file can include another configuration file using the\n\ninclude\n section directive. Note that the \nif-exists\n portion is optional\nand can be used if you don't want it to be an error if the included file\ndoes not exist.\n\n\n[include \"path/to/file.ini\" if-exists]\n\n\n\n\nSetting global options\n\n\nThe \n[__global__]\n section can be used to define options without a prefix.\n\n\n[__global__]\ndebug = true",
            "title": "Build Configuration"
        },
        {
            "location": "/config/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/config/#craftrninja",
            "text": "The path or name of the Ninja executable to invoke. Defaults to the  NINJA \nenvironment variable or simply  ninja .",
            "title": "craftr.ninja"
        },
        {
            "location": "/config/#configuring",
            "text": "On the command-line, you can use the  -d/--option  argument to set options.\nThese options override every option read from configuration files. Alternatively,\nyou can specify one or more configuration files to load with the  -c/--config \nargument. If none are specified, the file  .craftrconfig  in the current working\ndirectory is loaded if it exists.  If present, the file  .craftrconfig  in the users home directory will always\nbe loaded.  Configuration files are simple  .ini  files with two additions:",
            "title": "Configuring"
        },
        {
            "location": "/config/#include-configuration-files",
            "text": "A configuration file can include another configuration file using the include  section directive. Note that the  if-exists  portion is optional\nand can be used if you don't want it to be an error if the included file\ndoes not exist.  [include \"path/to/file.ini\" if-exists]",
            "title": "Include configuration files"
        },
        {
            "location": "/config/#setting-global-options",
            "text": "The  [__global__]  section can be used to define options without a prefix.  [__global__]\ndebug = true",
            "title": "Setting global options"
        },
        {
            "location": "/builtins/",
            "text": "This document describes the available built-in data members and functions in\na \nCraftrfile\n build script. Except for the package-specific variables, all\nbuilt-in functions and classes are defined in the \ncraftr.defaults\n module.\n\n\nPackage-specific variables\n\n\nproject_dir\n\n\nThe project directory. This is usually the same as the directory of the\nCraftr package manifest (\nmanifest.json\n), but can be altered with the\n\nproject_dir\n field in the manifest.\n\n\nThis variable has direct influence on the behaviour of the \nlocal()\n function.\n\n\noptions\n\n\nAn object that has as its members all options defined in the package manifest.\n\n\nif options.bad_weather:\n  logger.warn('be careful, you are choosing a build environment with bad weather')\n\n\n\n\nVariables\n\n\nlogger\n\n\nA \ncraftr.core.logging.BaseLogger\n instance. Use its \n.debug()\n, \n.info()\n,\n\n.warn()\n and \n.error()\n members to print information during the execution of\nthe build script.\n\n\nSee also: \nerror()\n built-in function\n\n\nsession\n\n\nThe current \ncraftr.core.session.Session\n object that manages the build process\nand Craftr packages. Sometimes you will want to modify its \n.options\n member\nor retrieve the currently executed Craftr module from its \n.module\n member.\n\n\nData\n\n\nDefault\n\n\nA singleton that can be used in places where \nNone\n can not be used as a\nplaceholder because it infers another special meaning. This is often used\nfor \nsuffix\n parameters of target generators.\n\n\nif suffix is Default:\n  suffix = derive_suffix_from_context()\nif suffix is not None:\n  output = path.addsuffix(output, suffix)\n\n\n\n\nFunctions\n\n\ngtn()\n\n\ninclude_defs()\n\n\nglob()\n\n\nlocal()\n\n\nbuildlocal()\n\n\nrelocate_files()\n\n\nfilter()\n\n\nmap()\n\n\nzip()\n\n\nload()\n\n\nload_file()\n\n\ngentool()\n\n\ngentarget()\n\n\ngentask()\n\n\ntask()\n\n\ngenalias()\n\n\nruntarget()\n\n\nwrite_response_file()\n\n\nerror()\n\n\nreturn_()\n\n\nappend_PATH()\n\n\nexternal_file(*urls, filename = None, directory = None, copy_file_urls = False, name = None)\n\n\nexternal_archive(*urls, directory = None, name = None)\n\n\npkg_config(pkg_name, static = False)\n\n\nUses \npkg-config\n to read the flags for the library specified with \npkg_name\n\nand returns a Framework object. If \npkg-config\n is not available on the platform\nor the library can not be found, \npkg_config.Error\n is raised.\n\n\nfrom craftr.loaders import pkg_config\ntry:\n  cURL = pkg_config('libcurl')\nexcept pkg_config.Error:\n  # compile from source or whatever\n\n\n\n\nClasses\n\n\nNamespace\n\n\nTargetBuilder\n\n\nFramework\n\n\nExceptions\n\n\nModuleError\n\n\nModuleReturn\n\n\nModuleNotFound\n\n\nToolDetectionError\n\n\nModules\n\n\npath\n\n\nshell\n\n\nplatform",
            "title": "Built-ins"
        },
        {
            "location": "/builtins/#package-specific-variables",
            "text": "",
            "title": "Package-specific variables"
        },
        {
            "location": "/builtins/#project_dir",
            "text": "The project directory. This is usually the same as the directory of the\nCraftr package manifest ( manifest.json ), but can be altered with the project_dir  field in the manifest.  This variable has direct influence on the behaviour of the  local()  function.",
            "title": "project_dir"
        },
        {
            "location": "/builtins/#options",
            "text": "An object that has as its members all options defined in the package manifest.  if options.bad_weather:\n  logger.warn('be careful, you are choosing a build environment with bad weather')",
            "title": "options"
        },
        {
            "location": "/builtins/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/builtins/#logger",
            "text": "A  craftr.core.logging.BaseLogger  instance. Use its  .debug() ,  .info() , .warn()  and  .error()  members to print information during the execution of\nthe build script.  See also:  error()  built-in function",
            "title": "logger"
        },
        {
            "location": "/builtins/#session",
            "text": "The current  craftr.core.session.Session  object that manages the build process\nand Craftr packages. Sometimes you will want to modify its  .options  member\nor retrieve the currently executed Craftr module from its  .module  member.",
            "title": "session"
        },
        {
            "location": "/builtins/#data",
            "text": "",
            "title": "Data"
        },
        {
            "location": "/builtins/#default",
            "text": "A singleton that can be used in places where  None  can not be used as a\nplaceholder because it infers another special meaning. This is often used\nfor  suffix  parameters of target generators.  if suffix is Default:\n  suffix = derive_suffix_from_context()\nif suffix is not None:\n  output = path.addsuffix(output, suffix)",
            "title": "Default"
        },
        {
            "location": "/builtins/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/builtins/#gtn",
            "text": "",
            "title": "gtn()"
        },
        {
            "location": "/builtins/#include_defs",
            "text": "",
            "title": "include_defs()"
        },
        {
            "location": "/builtins/#glob",
            "text": "",
            "title": "glob()"
        },
        {
            "location": "/builtins/#local",
            "text": "",
            "title": "local()"
        },
        {
            "location": "/builtins/#buildlocal",
            "text": "",
            "title": "buildlocal()"
        },
        {
            "location": "/builtins/#relocate_files",
            "text": "",
            "title": "relocate_files()"
        },
        {
            "location": "/builtins/#filter",
            "text": "",
            "title": "filter()"
        },
        {
            "location": "/builtins/#map",
            "text": "",
            "title": "map()"
        },
        {
            "location": "/builtins/#zip",
            "text": "",
            "title": "zip()"
        },
        {
            "location": "/builtins/#load",
            "text": "",
            "title": "load()"
        },
        {
            "location": "/builtins/#load_file",
            "text": "",
            "title": "load_file()"
        },
        {
            "location": "/builtins/#gentool",
            "text": "",
            "title": "gentool()"
        },
        {
            "location": "/builtins/#gentarget",
            "text": "",
            "title": "gentarget()"
        },
        {
            "location": "/builtins/#gentask",
            "text": "",
            "title": "gentask()"
        },
        {
            "location": "/builtins/#task",
            "text": "",
            "title": "task()"
        },
        {
            "location": "/builtins/#genalias",
            "text": "",
            "title": "genalias()"
        },
        {
            "location": "/builtins/#runtarget",
            "text": "",
            "title": "runtarget()"
        },
        {
            "location": "/builtins/#write_response_file",
            "text": "",
            "title": "write_response_file()"
        },
        {
            "location": "/builtins/#error",
            "text": "",
            "title": "error()"
        },
        {
            "location": "/builtins/#return_",
            "text": "",
            "title": "return_()"
        },
        {
            "location": "/builtins/#append_path",
            "text": "",
            "title": "append_PATH()"
        },
        {
            "location": "/builtins/#external_fileurls-filename-none-directory-none-copy_file_urls-false-name-none",
            "text": "",
            "title": "external_file(*urls, filename = None, directory = None, copy_file_urls = False, name = None)"
        },
        {
            "location": "/builtins/#external_archiveurls-directory-none-name-none",
            "text": "",
            "title": "external_archive(*urls, directory = None, name = None)"
        },
        {
            "location": "/builtins/#pkg_configpkg_name-static-false",
            "text": "Uses  pkg-config  to read the flags for the library specified with  pkg_name \nand returns a Framework object. If  pkg-config  is not available on the platform\nor the library can not be found,  pkg_config.Error  is raised.  from craftr.loaders import pkg_config\ntry:\n  cURL = pkg_config('libcurl')\nexcept pkg_config.Error:\n  # compile from source or whatever",
            "title": "pkg_config(pkg_name, static = False)"
        },
        {
            "location": "/builtins/#classes",
            "text": "",
            "title": "Classes"
        },
        {
            "location": "/builtins/#namespace",
            "text": "",
            "title": "Namespace"
        },
        {
            "location": "/builtins/#targetbuilder",
            "text": "",
            "title": "TargetBuilder"
        },
        {
            "location": "/builtins/#framework",
            "text": "",
            "title": "Framework"
        },
        {
            "location": "/builtins/#exceptions",
            "text": "",
            "title": "Exceptions"
        },
        {
            "location": "/builtins/#moduleerror",
            "text": "",
            "title": "ModuleError"
        },
        {
            "location": "/builtins/#modulereturn",
            "text": "",
            "title": "ModuleReturn"
        },
        {
            "location": "/builtins/#modulenotfound",
            "text": "",
            "title": "ModuleNotFound"
        },
        {
            "location": "/builtins/#tooldetectionerror",
            "text": "",
            "title": "ToolDetectionError"
        },
        {
            "location": "/builtins/#modules",
            "text": "",
            "title": "Modules"
        },
        {
            "location": "/builtins/#path",
            "text": "",
            "title": "path"
        },
        {
            "location": "/builtins/#shell",
            "text": "",
            "title": "shell"
        },
        {
            "location": "/builtins/#platform",
            "text": "",
            "title": "platform"
        },
        {
            "location": "/loaders/",
            "text": "If you're project provides some examples that depend on huge binary data,\nyou can download these files when necessary:\n\n\nif options.build_examples:\n  example_data = external_file(\"http://url.to/example/data.bin\")\n  # ... build examples here\n\n\n\n\nMany build scripts for projects that are not usually built with Craftr\nuse the \nexternal_archive()\n function to download a source archive and\nbuild from that.\n\n\nsource_directory = external_archive(\n  \"https://curl.haxx.se/download/curl-{}.tar.gz\".format(options.version)\n)\n\n# ...\n\n\n\n\nFor details on these functions, check the \nBuilt-ins Documentation",
            "title": "Loaders"
        },
        {
            "location": "/tasks/",
            "text": "Tasks\n\n\nCraftr allows you to embed actual Python functions into the build process. We\ncall this concept \"tasks\". Tasks end up being plain rules and build instructions\nin the Ninja manifest. They will then be invoked using the \ncraftr run\n command.\nNote that for each task that is executed, your build-script is also executed\nanother time.\n\n\nYou can build functions that create tasks, so you can create multiple instances\nof the same task with different inputs, or you just create a task once from a\nsingle function.\n\n\nA simple example\n\n\ngit = load('craftr.utils.git').Git(project_dir)  # Git repository helper for this project\n\n@task(outputs = [buildlocal('include/gitversion.h')])\ndef gitversion(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n\n\n\nWe can then compile a C-program that includes the generated \ngitversion.h\n\nfile, but we must ensure that the task is executed \nbefore\n the C-program\nis compiled.\n\n\ncxx = load('craftr.lang.cxx')\napp = cxx.binary(\n  output = 'main',\n  inputs = cxx.c_compile(\n    sources = glob(['src/*.c']),\n    include = [buildlocal('include')]\n  ) << gitversion\n)\n\n\n\n\nTask generators\n\n\nWe can generalise the \ngitversion\n task so it can be used multiple times.\n\n\nGit = load('craftr.utils.git').Git  # Git repository helper for this project\n\ndef write_gitversion(project_dir = None):\n  if not project_dir:\n    project_dir = session.module.project_dir\n  git = Git(project_dir)\n\n  def worker(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n  outputs = [buildlocal('include/gitversion.h')]\n  return gentask(worker, outputs = outputs, name = gtn())\n\ngitversion = write_gitversion()",
            "title": "Tasks"
        },
        {
            "location": "/tasks/#tasks",
            "text": "Craftr allows you to embed actual Python functions into the build process. We\ncall this concept \"tasks\". Tasks end up being plain rules and build instructions\nin the Ninja manifest. They will then be invoked using the  craftr run  command.\nNote that for each task that is executed, your build-script is also executed\nanother time.  You can build functions that create tasks, so you can create multiple instances\nof the same task with different inputs, or you just create a task once from a\nsingle function.  A simple example  git = load('craftr.utils.git').Git(project_dir)  # Git repository helper for this project\n\n@task(outputs = [buildlocal('include/gitversion.h')])\ndef gitversion(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))  We can then compile a C-program that includes the generated  gitversion.h \nfile, but we must ensure that the task is executed  before  the C-program\nis compiled.  cxx = load('craftr.lang.cxx')\napp = cxx.binary(\n  output = 'main',\n  inputs = cxx.c_compile(\n    sources = glob(['src/*.c']),\n    include = [buildlocal('include')]\n  ) << gitversion\n)  Task generators  We can generalise the  gitversion  task so it can be used multiple times.  Git = load('craftr.utils.git').Git  # Git repository helper for this project\n\ndef write_gitversion(project_dir = None):\n  if not project_dir:\n    project_dir = session.module.project_dir\n  git = Git(project_dir)\n\n  def worker(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n  outputs = [buildlocal('include/gitversion.h')]\n  return gentask(worker, outputs = outputs, name = gtn())\n\ngitversion = write_gitversion()",
            "title": "Tasks"
        },
        {
            "location": "/generators/",
            "text": "Most of them time you will be using functions that generate build targets\nfrom some input information instead of hardcoding the exact command-line\narguments for a target. These we call \"target generators\".\n\n\nYou can create a target manually with the \ngentarget()\n builtin function\nvery easily and this is useful if you need exact control over the command\nthat is run for the target.\n\n\nmain = gentarget(\n  commands = ['gcc $in -o $out'.split()],\n  inputs = glob(['src/*.c']),\n  outputs = ['main']\n)\n\n\n\n\nBut that is of course not portable to platforms that do not have the GCC\ncompiler. Also, maybe you need some more logic to generate the build command,\nand in that case you might also want to reuse that logic on another target.\n\n\nSimple target generator\n\n\nSo instead of hardcoding the command, let's wrap it in a function that\ngenereates it for us.\n\n\ndef gcc_binary(sources, output, name=None):\n  command = 'gcc $in -o $out'.split()\n  return gentarget([command], sources, [output], name=gtn(name, 'gcc_binary'))\n\nmain = gcc_binary(\n  sources = glob(['src/*.c']),\n  output = 'main'\n)\n\n\n\n\nI think everything is here is straightforward, except maybe for the\n\ngtn(name, 'gcc_binary')\n part. What this function does is deriving the name\nof the target from the variable that the result of the function is assigned\nto, in this case the target name will be \nmain\n (prefixed with the identifer\nof your Craftr package). We can however specify an alternative name for the\ntarget with the \nname\n argument, or otherwise if the function is not assigned\nto a variable and no \nname\n argument is specified, default to the specified\n\n'gcc_binary'\n name (with some numeric suffix to avoid target name collision).\n\n\nNow this was a lot to take into. You don't need to fully understand what's\nhappening, you only need to understand that \ngtn()\n is what is used to derive\ntarget names from when implementing target generators.\n\n\nThe TargetBuilder\n\n\nThe \nTargetBuilder\n class does a lot of stuff for us that is very useful when\nimplementing target generators. Most of the target generators provided by\nCraftr's standard library use this class. It's constructor takes 4 important\narguments:\n\n\n\n\nname\n -- The name of the target. Again, use \ngtn(name, 'alternative')\n\n   as value for this parameter.\n\n\noption_kwargs\n -- Optional, this is usually a dictionary of additional\n   keyword arguments that have been passed when calling the target generator\n   function. These keyword arguments are included into the \nOptionMerge\n that\n   is created internally by the \nTargetBuilder\n (more on that later).\n\n\nframeworks\n -- Optional, a list of \nFramework\n objects which are to be\n   include in the \nOptionMerge\n that is created internally by the\n   \nTargetBuilder\n (more on that later). Unlike the \noption_kwargs\n, these\n   frameworks are inherited by the created \nTarget\n\n\ninputs\n -- Optional, inputs for the target. This can be a single \nTarget\n\n   object, or a list of mixed \nTarget\n objects and strings which must be\n   filenames. For every \nTarget\n in this parameter, its output files are\n   included in the list of input files (see \nTargetBuilder.inputs\n) and all\n   frameworks from these targets are inherited (see \nTargetBuilder.frameworks\n).\n\n\n\n\nNow after the \nTargetBuilder\n was created, it has three important methods:\n\n\n\n\nget(key, default)\n -- Get an option from the \nOptionMerge\n created by the\n  \nTargetBuilder\n. This effectively returns the first value found for \nkey\n\n  in the \noption_kwargs\n and \nframeworks\n specified on construction as\n  well as any inherited frameworks.\n\n\nget_list(key)\n -- Like \nget()\n, but this expects all values found under\n  \nkey\n to be lists and joins them all into one list. This is especially useful\n  for specifying accumulating options like include directories, preprocessor\n  defines, library search paths and link library names, etc.\n\n\nbuild(commands, inputs=None, outputs=None, implicit_deps=None, order_only_deps=None, metadata=None, **kwargs)\n\n  -- Create a \nTarget\n object. Basically all these arguments are passed to the\n  \ncraftr.core.build.Target\n constructor and the \nTargetBuilder.name\n is used as\n  the targets name. Note that \ncommands\n must always be a list of commands,\n  and every command must be a list of strings (the arguments).\n\n\n\n\nLooking at our above exaple, let's do it with a \nTargetBuilder\n and extend it\na bit further:\n\n\ndef gcc_binary(sources, output, name=None, frameworks=(), **kwargs):\n  builder = TargetBuilder(gtn(name, 'gcc_binary'), kwargs, frameworks, sources)\n  output = buildlocal(path.addsuffix(output, platform.bin))\n  command = ['gcc', '$in', '-o', '$out']\n  for fn in builder.get_list('include'):\n    command.append('-I' + fn)\n  for define in builder.get_list('defines'):\n    command.append('-D' + define)\n  for lib in builder.get_list('libs'):\n    command.append('-l' + lib)\n  if builder.get('debug', False):\n    command += ['-g', '-O0']\n  return builder.build([command], outputs=[output])\n\nsome_library = Framework('some_library',\n  include = [local('vendor/some_library/include')],\n  defines = ['USE_SOME_LIBRARY=1'],\n  libs = ['some_library']\n)\n\nmain = gcc_binary(\n  sources = glob(['src/*.c']),\n  output = 'main',\n  include = [local('include')],\n  debug = True,\n  frameworks = [some_library]\n)",
            "title": "Generators"
        },
        {
            "location": "/generators/#simple-target-generator",
            "text": "So instead of hardcoding the command, let's wrap it in a function that\ngenereates it for us.  def gcc_binary(sources, output, name=None):\n  command = 'gcc $in -o $out'.split()\n  return gentarget([command], sources, [output], name=gtn(name, 'gcc_binary'))\n\nmain = gcc_binary(\n  sources = glob(['src/*.c']),\n  output = 'main'\n)  I think everything is here is straightforward, except maybe for the gtn(name, 'gcc_binary')  part. What this function does is deriving the name\nof the target from the variable that the result of the function is assigned\nto, in this case the target name will be  main  (prefixed with the identifer\nof your Craftr package). We can however specify an alternative name for the\ntarget with the  name  argument, or otherwise if the function is not assigned\nto a variable and no  name  argument is specified, default to the specified 'gcc_binary'  name (with some numeric suffix to avoid target name collision).  Now this was a lot to take into. You don't need to fully understand what's\nhappening, you only need to understand that  gtn()  is what is used to derive\ntarget names from when implementing target generators.",
            "title": "Simple target generator"
        },
        {
            "location": "/generators/#the-targetbuilder",
            "text": "The  TargetBuilder  class does a lot of stuff for us that is very useful when\nimplementing target generators. Most of the target generators provided by\nCraftr's standard library use this class. It's constructor takes 4 important\narguments:   name  -- The name of the target. Again, use  gtn(name, 'alternative') \n   as value for this parameter.  option_kwargs  -- Optional, this is usually a dictionary of additional\n   keyword arguments that have been passed when calling the target generator\n   function. These keyword arguments are included into the  OptionMerge  that\n   is created internally by the  TargetBuilder  (more on that later).  frameworks  -- Optional, a list of  Framework  objects which are to be\n   include in the  OptionMerge  that is created internally by the\n    TargetBuilder  (more on that later). Unlike the  option_kwargs , these\n   frameworks are inherited by the created  Target  inputs  -- Optional, inputs for the target. This can be a single  Target \n   object, or a list of mixed  Target  objects and strings which must be\n   filenames. For every  Target  in this parameter, its output files are\n   included in the list of input files (see  TargetBuilder.inputs ) and all\n   frameworks from these targets are inherited (see  TargetBuilder.frameworks ).   Now after the  TargetBuilder  was created, it has three important methods:   get(key, default)  -- Get an option from the  OptionMerge  created by the\n   TargetBuilder . This effectively returns the first value found for  key \n  in the  option_kwargs  and  frameworks  specified on construction as\n  well as any inherited frameworks.  get_list(key)  -- Like  get() , but this expects all values found under\n   key  to be lists and joins them all into one list. This is especially useful\n  for specifying accumulating options like include directories, preprocessor\n  defines, library search paths and link library names, etc.  build(commands, inputs=None, outputs=None, implicit_deps=None, order_only_deps=None, metadata=None, **kwargs) \n  -- Create a  Target  object. Basically all these arguments are passed to the\n   craftr.core.build.Target  constructor and the  TargetBuilder.name  is used as\n  the targets name. Note that  commands  must always be a list of commands,\n  and every command must be a list of strings (the arguments).   Looking at our above exaple, let's do it with a  TargetBuilder  and extend it\na bit further:  def gcc_binary(sources, output, name=None, frameworks=(), **kwargs):\n  builder = TargetBuilder(gtn(name, 'gcc_binary'), kwargs, frameworks, sources)\n  output = buildlocal(path.addsuffix(output, platform.bin))\n  command = ['gcc', '$in', '-o', '$out']\n  for fn in builder.get_list('include'):\n    command.append('-I' + fn)\n  for define in builder.get_list('defines'):\n    command.append('-D' + define)\n  for lib in builder.get_list('libs'):\n    command.append('-l' + lib)\n  if builder.get('debug', False):\n    command += ['-g', '-O0']\n  return builder.build([command], outputs=[output])\n\nsome_library = Framework('some_library',\n  include = [local('vendor/some_library/include')],\n  defines = ['USE_SOME_LIBRARY=1'],\n  libs = ['some_library']\n)\n\nmain = gcc_binary(\n  sources = glob(['src/*.c']),\n  output = 'main',\n  include = [local('include')],\n  debug = True,\n  frameworks = [some_library]\n)",
            "title": "The TargetBuilder"
        },
        {
            "location": "/transition/",
            "text": "This document should give you a quick idea of how to transition your Craftr 1\nbuild scripts to Craftr 2.x. Not too much has changed in terms of the build\nscripts, mainly the way other scripts are imported is different.\n\n\nInstead of using Python-style imports, you use the \nload_module()\n builtin\nfunction in Craftr 2. Below we show the old and new way of importing the C/C++\ntarget generators.\n\n\nfrom craftr.ext.platform import cc, cxx, ld, ar    # old\ncxc = load_module('craftr.lang.cxx').cxc                  # new\n\n\n\n\nHowever what we usually do in Craftr 2 now is to use star-imports to\nload the contents of the module into the global namespace.\n\n\nload_module('craftr.lang.cxx.*')\n\n\n\n\nDoing the transition\n\n\nUse the \ncraftr startpackage\n command to create the manifest and build script\nfiles in your project. If you want to keep your root directory clean, use the\n\n-n/--nested\n option.\n\n\n$ cd my-project\n$ craftr startpackage my_project . --nested\n\n\n\nOpen the \nmanifest.json\n file and make sure to include all the dependencies\nthat you need (eg. \n\"craftr.lang.cxx\": \"*\"\n). Craftr 2 refuses to load a module if\nit is not defined in the package's dependencies.\n\n\nNow you can basically copy the content from your old \nCraftfile.py\n to the\nnew \nCraftrfile\n and make the adjustments.\n\n\nCompiler abstraction changes\n\n\nC/C++\n\n\nIn Craftr 1, there were separate objects depending on what you wanted to\ndo: compile C, C++, link or create a static library. In Craftr 2, there is\none object that can do all of it: \ncxc\n. There have been some changes to\nthe \ncompile()\n and \nlink()\n interface, but the most important one is that\n\ncompile()\n now requires a \nlanguage\n parameter which can be either one of\n\n'c', 'c++', 'asm'\n.\n\n\nThe \nlang.cxx\n module provides the following three new functions that should\nbe used instead:\n\n\n\n\nc_compile()\n\n\ncpp_compile()\n\n\ncxx_binary()\n\n\ncxx_link()\n\n\n\n\nNote that \ncxx_link()\n has a \nlink_style\n parameter that is \n'static'\n by\ndefault but can be set to \n'shared'\n to produce a shared library.\n\n\nCython\n\n\nThe interface is pretty much the same, only \ncythonc.compile_project()\n is now\nonly \ncythonc.compile()\n. There are named wrapper available when using starred\nimports, namely\n\n\n\n\ncython_compile()\n\n\ncython_project()\n\n\n\n\nJava\n\n\n\n\njava_compile()\n\n\njava_jar()\n\n\n\n\nC\n\n\n\n\ncsharp_compile()",
            "title": "Transition from Craftr 1"
        },
        {
            "location": "/transition/#doing-the-transition",
            "text": "Use the  craftr startpackage  command to create the manifest and build script\nfiles in your project. If you want to keep your root directory clean, use the -n/--nested  option.  $ cd my-project\n$ craftr startpackage my_project . --nested  Open the  manifest.json  file and make sure to include all the dependencies\nthat you need (eg.  \"craftr.lang.cxx\": \"*\" ). Craftr 2 refuses to load a module if\nit is not defined in the package's dependencies.  Now you can basically copy the content from your old  Craftfile.py  to the\nnew  Craftrfile  and make the adjustments.",
            "title": "Doing the transition"
        },
        {
            "location": "/transition/#compiler-abstraction-changes",
            "text": "",
            "title": "Compiler abstraction changes"
        },
        {
            "location": "/transition/#cc",
            "text": "In Craftr 1, there were separate objects depending on what you wanted to\ndo: compile C, C++, link or create a static library. In Craftr 2, there is\none object that can do all of it:  cxc . There have been some changes to\nthe  compile()  and  link()  interface, but the most important one is that compile()  now requires a  language  parameter which can be either one of 'c', 'c++', 'asm' .  The  lang.cxx  module provides the following three new functions that should\nbe used instead:   c_compile()  cpp_compile()  cxx_binary()  cxx_link()   Note that  cxx_link()  has a  link_style  parameter that is  'static'  by\ndefault but can be set to  'shared'  to produce a shared library.",
            "title": "C/C++"
        },
        {
            "location": "/transition/#cython",
            "text": "The interface is pretty much the same, only  cythonc.compile_project()  is now\nonly  cythonc.compile() . There are named wrapper available when using starred\nimports, namely   cython_compile()  cython_project()",
            "title": "Cython"
        },
        {
            "location": "/transition/#java",
            "text": "java_compile()  java_jar()",
            "title": "Java"
        },
        {
            "location": "/transition/#c",
            "text": "csharp_compile()",
            "title": "C"
        },
        {
            "location": "/faq/",
            "text": "FAQ\n\n\nHow to use an alternative Ninja command?\n\n\nYou can set the \ncraftr.ninja\n option or use the \nNINJA\n environment variable.\n\n\n$ craftr -d craftr.ninja=ninja-1.7.2 build\n\n\n\nIs there a way to create a Python function that is called from Ninja?\n\n\nCurrently not. Craftr 1 used to have this feature called \nRTS\n. Including\nthis feature into Craftr 2 is definitely on the plan.\n\n\nHow can I include a configuration file from another configuration file?\n\n\nYou can use the \n[include \"path/to/config\" if-exists]\n section directive. Note\nthat the \nif-exists\n part is optional.\n\n\nHow can I set a global option in a configuration file?\n\n\nYou can add the options under the \n[__global__]\n section.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/faq/#how-to-use-an-alternative-ninja-command",
            "text": "You can set the  craftr.ninja  option or use the  NINJA  environment variable.  $ craftr -d craftr.ninja=ninja-1.7.2 build",
            "title": "How to use an alternative Ninja command?"
        },
        {
            "location": "/faq/#is-there-a-way-to-create-a-python-function-that-is-called-from-ninja",
            "text": "Currently not. Craftr 1 used to have this feature called  RTS . Including\nthis feature into Craftr 2 is definitely on the plan.",
            "title": "Is there a way to create a Python function that is called from Ninja?"
        },
        {
            "location": "/faq/#how-can-i-include-a-configuration-file-from-another-configuration-file",
            "text": "You can use the  [include \"path/to/config\" if-exists]  section directive. Note\nthat the  if-exists  part is optional.",
            "title": "How can I include a configuration file from another configuration file?"
        },
        {
            "location": "/faq/#how-can-i-set-a-global-option-in-a-configuration-file",
            "text": "You can add the options under the  [__global__]  section.",
            "title": "How can I set a global option in a configuration file?"
        }
    ]
}