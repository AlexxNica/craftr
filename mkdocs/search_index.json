{
    "docs": [
        {
            "location": "/",
            "text": "The Craftr build system\n\n\n\n\n\n\nCraftr is a meta build system based on \nPython 3\n scripts which produces\n\nNinja\n build manifests. It enforces the use of modular build definitions\nthat can be re-used easily and ships with a standard library supporting\nvarious programming languages and common libraries.\n\n\n\n\nDocumentation\n\n\nGetting Started\n\n\nCraftr 2.x Wiki\n\n\n\n\nFeatures\n\n\n\n\n[x] Aims to be cross-platform compatible (regularly tested on Windows, Mac OS and Linux)\n\n\n[x] Build definitions divided into versioned modules\n\n\n[x] Embedd actual Python functions into the build process (keyword Tasks)\n\n\n[x] Dependency-lock files for fully reproducible builds\n\n\n[ ] Package manager (hosted on \nCraftr.net\n)\n\n\n\n\nBasic Usage\n\n\n$ craftr version                            # Print Craftr version and exit\n$ craftr export                             # Generate Ninja manifest\n$ craftr build [target [target [...]]]      # Build all or the specified target(s)\n$ craftr clean [-r] [target [target [...]]] # Clean all or the specified target(s)\n$ craftr startpackage <name> [directory]    # Start a new Craftr project (manifest, Craftrfile)\n$ craftr lock                               # Generate a .dependency-lock file (after craftr export)\n\n\n\n\nC++ Example\n\n\ncxx = load('craftr.lang.cxx')\nprogram = cxx.executable(\n  inputs = cxx.compile_cpp(sources = glob('src/**/*.cpp')),\n  output = 'main'\n)\n\n\n\n\nJava Example\n\n\njava = load('craftr.lang.java')\njar = java.jar(\n  inputs = java.compile(src_dir = local('src')),\n  output = 'myapp',\n  entry_point = 'Main'\n)\n\n\n\n\nC# Example\n\n\ncs = load('craftr.lang.csharp')\napp = cs.compile(\n  sources = glob('src/**/*.cs'),\n  output = 'Main',\n  target = 'exe'\n)\n\n\n\n\nCython Exmple\n\n\ncython = load('craftr.lang.cython')\nprimes = cython.project(\n  sources = [local('Primes.pyx')],\n  main = local('Main.pyx')\n)\nrun = runtarget(primes.main)\n\n\n\n\nHow to Contribute\n\n\nPlease \ncreate an Issue\n if\nyou have any questions, problems or feature requests.\n\n\nInstallation\n\n\nMake sure you specify the specific version you want to install since there is\nno untagged version of Craftr 2.x available on PyPI yet and otherwise Pip will\ninstall Craftr 1.x (which is quite different). To get the newest stable version\nof Craftr 2, use\n\n\n$ pip install craftr-build==2.0.0.dev7\n\n\n\n\nTo get the cutting edge development version, I suggest installing Craftr\nfrom the Git repository into a virtualenv.\n\n\n$ virtualenv -p python3 env && source env/bin/activate\n$ git clone https://github.com/craftr-build/craftr.git -b development\n$ cd craftr\n$ pip install -e .\n\n\n\n\nRequirements\n\n\n\n\nNinja\n 1.7.1 or newer\n\n\nCPython\n 3.4 or 3.5\n\n\n\n\nPython Dependencies (automatically installed)\n\n\n\n\ncolorama\n (optional, Windows)\n\n\nglob2\n\n\njsonschema\n\n\nninja_syntax\n\n\nnr\n\n\npy-require\n\n\ntermcolor\n (optional)\n\n\nwerkzeug\n\n\n\n\nLicense\n\n\nThe Craftr build system\nCopyright (C) 2016  Niklas Rosenstein\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\n\nFor more information, see the \nLICENSE.txt\n file.",
            "title": "Home"
        },
        {
            "location": "/#the-craftr-build-system",
            "text": "Craftr is a meta build system based on  Python 3  scripts which produces Ninja  build manifests. It enforces the use of modular build definitions\nthat can be re-used easily and ships with a standard library supporting\nvarious programming languages and common libraries.   Documentation  Getting Started  Craftr 2.x Wiki   Features   [x] Aims to be cross-platform compatible (regularly tested on Windows, Mac OS and Linux)  [x] Build definitions divided into versioned modules  [x] Embedd actual Python functions into the build process (keyword Tasks)  [x] Dependency-lock files for fully reproducible builds  [ ] Package manager (hosted on  Craftr.net )   Basic Usage  $ craftr version                            # Print Craftr version and exit\n$ craftr export                             # Generate Ninja manifest\n$ craftr build [target [target [...]]]      # Build all or the specified target(s)\n$ craftr clean [-r] [target [target [...]]] # Clean all or the specified target(s)\n$ craftr startpackage <name> [directory]    # Start a new Craftr project (manifest, Craftrfile)\n$ craftr lock                               # Generate a .dependency-lock file (after craftr export)  C++ Example  cxx = load('craftr.lang.cxx')\nprogram = cxx.executable(\n  inputs = cxx.compile_cpp(sources = glob('src/**/*.cpp')),\n  output = 'main'\n)  Java Example  java = load('craftr.lang.java')\njar = java.jar(\n  inputs = java.compile(src_dir = local('src')),\n  output = 'myapp',\n  entry_point = 'Main'\n)  C# Example  cs = load('craftr.lang.csharp')\napp = cs.compile(\n  sources = glob('src/**/*.cs'),\n  output = 'Main',\n  target = 'exe'\n)  Cython Exmple  cython = load('craftr.lang.cython')\nprimes = cython.project(\n  sources = [local('Primes.pyx')],\n  main = local('Main.pyx')\n)\nrun = runtarget(primes.main)",
            "title": "The Craftr build system"
        },
        {
            "location": "/#how-to-contribute",
            "text": "Please  create an Issue  if\nyou have any questions, problems or feature requests.",
            "title": "How to Contribute"
        },
        {
            "location": "/#installation",
            "text": "Make sure you specify the specific version you want to install since there is\nno untagged version of Craftr 2.x available on PyPI yet and otherwise Pip will\ninstall Craftr 1.x (which is quite different). To get the newest stable version\nof Craftr 2, use  $ pip install craftr-build==2.0.0.dev7  To get the cutting edge development version, I suggest installing Craftr\nfrom the Git repository into a virtualenv.  $ virtualenv -p python3 env && source env/bin/activate\n$ git clone https://github.com/craftr-build/craftr.git -b development\n$ cd craftr\n$ pip install -e .",
            "title": "Installation"
        },
        {
            "location": "/#requirements",
            "text": "Ninja  1.7.1 or newer  CPython  3.4 or 3.5   Python Dependencies (automatically installed)   colorama  (optional, Windows)  glob2  jsonschema  ninja_syntax  nr  py-require  termcolor  (optional)  werkzeug",
            "title": "Requirements"
        },
        {
            "location": "/#license",
            "text": "The Craftr build system\nCopyright (C) 2016  Niklas Rosenstein\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.  For more information, see the  LICENSE.txt  file.",
            "title": "License"
        },
        {
            "location": "/getting-started/",
            "text": "Note\n: The example we create in this tutorial can also be found in the\n\nexamples/examples.c\n folder.\n\n\n\n\nEvery project that is compiled with Craftr needs at least a manifest and a\nbuild script. Craftr provides a convenient way to generate a template for you.\nChoose your project directory and run the following command\n\n\n$ craftr startpackage examples.c .\n\n\n\n\nThen open the \nmanifest.cson\n file that was created and add the generic C/C++\nmodule as a dependency. With \n\"*\"\n we specify that the newest version of the\nmodule that is available should be used.\n\n\nname: \"examples.c\"\nversion: \"1.0.0\"\ndependencies:\n  \"craftr.lang.cxx\": \"*\"\noptions: {}\n\n\n\n\nNow let's assume we have the following two C source files in our project\ndirectory as well.\n\n\n$ cat src/main.c\n\nextern void say_hello(char const* name, char const* weather);\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    printf(\"error: usage: %s name weather\\n\");\n    return 0;\n  }\n  say_hello(argv[1], argv[2]);\n  return 0;\n}\n\n$ cat src/hello.c\n\n#include <stdio.h>\n\nvoid say_hello(char const* name, char const* weather) {\n  printf(\"Hello, %s. You are facing a %s day\\n\", name, weather);\n}\n\n\n\n\nWe want our build script to compile these two files into object files and then\nlink them together into an executable. Additionally, the build script should\nallow us to make a test run of the program.\n\n\n$ cat Craftrfile\n# examples.c\n\ncxx = load('craftr.lang.cxx')\n\nprogram = cxx.executable(\n  inputs = cxx.compile_c(sources = glob(['src/*.c'])),\n  output = 'main'\n)\n\nfrom os import environ\nrun = runtarget(program, environ.get('USERNAME', 'John'), \"sunny\")\n\n\n\n\nAnd that's it. To compile our program, we first need to export a Ninja build\nmanifest, then we can build it. Our \nrun\n target is explicit by default, meaning\nthat Ninja will not run it unless it is specified as an input or specified as\na target to build on the command-line.\n\n\n$ craftr export\ncraftr.lang.cxx: loading \"craftr.lang.cxx.msvc\" (with craftr.lang.cxx.msvc.toolkit=\"\")\ncraftr.lang.cxx:   cxc.name=\"msvc\"\ncraftr.lang.cxx:   cxc.target_arch=\"x64\"\ncraftr.lang.cxx:   cxc.version=\"19.00.23918\"\n$ craftr build\n[1/3] msvc compile (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\obj\\src\\main.obj)\n[2/3] msvc compile (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\obj\\src\\hello.obj)\n[3/3] msvc link (C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\main.exe)\n$ craftr build run\n[0/1] C:\\Users\\niklas\\Desktop\\test\\build\\examples.c-1.0.0\\main.exe niklas sunny\nHello, niklas. You are facing a sunny day",
            "title": "Getting Started"
        },
        {
            "location": "/ref/package/",
            "text": "A Craftr \npackage\n consists of at least two files: A manifest and build script.\nWe also call the build script \nmodule\n. These files can be placed in your\nproject root directory or in a sub-directory with the name \ncraftr/\n. The nested\nstructure is usually used for larger projects that have a complex file tree to\nkeep the root directory cleaner.\n\n\nAlso, there can be a \n.craftrconfig\n depending on where the \nmanifest.cson\n\nis located which will be loaded before anything else. For more information on\nconfiguration, see the \nConfig documentation\n.\n\n\n  Standard                   Nested\n\n|  project/               |  project/\n|    .craftrconfig        |    craftr/\n|    manifest.cson        |      .craftrconfig\n|    Craftrfile           |      manifest.cson\n|    source/              |      Craftrfile\n|                         |    source/\n\n\n\n\nNote that in the nested format, you want to make sure to set the\n\nproject_dir\n field in the manifest to \n\"..\"\n.\n\n\nPackage manifest\n\n\nBelow you can find a list of all the available fields in a \nmanifest.cson\n file.\nNote that you can use the \ncraftr startpackage\n command to quickly generate a\nmanifest for your project.\n\n\nExample manifest:\n\n\nname: \"craftr.lib.curlpp\"\nversion: \"1.0.0\"\ndependencies:\n  \"craftr.lang.cxx\": \"*\"\n  \"craftr.lib.curl\": \"*\"\noptions:\n  version:\n    type: \"string\"\n    default: \"v0.7.3\"\n  static:\n    type: \"bool\"\n    help: \"Whether to build a static or dynamic library. Must match the linkage of cURL.\"\n    default: true\n  rtti:\n    type: \"bool\"\n    default: true\n\n\n\n\nname\n\n\nRequired\n. The name of the Craftr package. This name must only consist of\nletters, digits, dots and underscores. The name of a package must be unique\nin the Craftr ecosystem, however if you are sure that you will never submit\nthe package to [Craftr.net], you can choose whatever you like.\n\n\nversion\n\n\nRequired\n. A semantic versioning number for the package. This version number\nis used to find and load the correct package version when resoloving dependencies.\nNote that Craftr can load the same package multiple times, given they have\ndifferent version numbers.\n\n\ndescription\n\n\nOptional\n. A short description of what the package does and what it is used\nfor.\n\n\nauthor\n\n\nOptional\n. The name of the author of the package and optionally his/her email\naddress. If given, the email address should be enclosed in angle brackets, like\n\n\"John Peter <john.peter@fakemail.com>\"\n.\n\n\nurl\n\n\nOptional\n. URL to the project website. Most likely a link to the GitHub page.\n\n\noptions\n\n\nOptional\n. An object that describes available options for the package. The\nfields for this object are the option names. These fields again map to objects\nthat describe the option parameter \nor\n simply the option type name. Example:\n\n\noptions\":\n  directory: \"path\"\n  build_examples:\n    \"type\": \"bool\"\n    \"help\": \"Whether to build example files\"\n\n\n\n\nAvailable fields:\n\n\ntype\n\n\nRequire\n. The type of the option. Available option types are \n\"bool\"\n,\n\n\"triplet\"\n and \n\"string\"\n.\n\n\ndefault\n\n\nOptional\n. The default value of the option if no explicit value is defined.\nThe default value of this field depends on the option \ntype\n.\n\n\nhelp\n\n\nOptional\n. A short description of what the option is used for.\n\n\ninherit\n\n\nOptional\n. Defaults to \ntrue\n. If this field is \ntrue\n and the value of the\noption is not defined explicitly, the global option with the same name will be\ninherited. For example if your package is called \nsome.cool.package\n and the\noption name is \nbuild_examples\n, then the full qualified option name would be\n\nsome.cool.package.build_examples\n. Now if this option is not set but a global\noption \nbuild_examples\n is set, this value will be used for the option.\n\n\ndependencies\n\n\nOptional\n. An object that describes the dependencies of the package. The\nfields of this object are the names of the required Craftr packages. The\nvalue of each field is a \nversion criteria\n, that is a string which specifies\none exact version number or a range of accepted version numbers. The format is\nsimilar to \nnpm\n version selectors. Examples:\n\n\n\"craftr.lib.curl\": \"*\"          // any version, but the newest we can get\n\"craftr.lib.curl\": \"=1.2.9\"     // exactly version 1.2.9\n\"craftr.lib.curl\": \"1.3 - 1.8\"  // any version between 1.3.0 and 1.8.0\n\"craftr.lib.curl\": \"2.x.2\"      // major and patch version 2, but any minor version\n\n\n\n\nNote that Craftr will refuse to load modules with \nload_module()\n that are not\nlisted in the manifest \ndependencies\n!\n\n\n\n\nImportant\n: Keep in mind that the version number defined in the\n\ndependencies\n are the version numbers of Craftr packages, not necessarily\nthe version of the actual library that can be used with it.\n\n\n\n\nmain\n\n\nOptional\n. The name of the build script. Usually you don't need/want to set\nthis field. The default value is \n\"Craftrfile\"\n.\n\n\nproject_dir\n\n\nOptional\n. A relative path the alters the \nproject_dir\n variable in the Craftr\nbuild script. This influences the way the \nlocal()\n built-in function behaves.\nFor more information on built-in functions, see the \nBuiltins documentation\n.\n\n\nNote that you usually want this field to be set to \n\"..\"\n if you are using the\nnested project structure. The \ncraftr startpackage\n command has a \n-n/--nested\n\noption which creates a nested project structure and also sets this \nproject_dir\n\nfield.",
            "title": "Package Description"
        },
        {
            "location": "/ref/package/#package-manifest",
            "text": "Below you can find a list of all the available fields in a  manifest.cson  file.\nNote that you can use the  craftr startpackage  command to quickly generate a\nmanifest for your project.  Example manifest:  name: \"craftr.lib.curlpp\"\nversion: \"1.0.0\"\ndependencies:\n  \"craftr.lang.cxx\": \"*\"\n  \"craftr.lib.curl\": \"*\"\noptions:\n  version:\n    type: \"string\"\n    default: \"v0.7.3\"\n  static:\n    type: \"bool\"\n    help: \"Whether to build a static or dynamic library. Must match the linkage of cURL.\"\n    default: true\n  rtti:\n    type: \"bool\"\n    default: true",
            "title": "Package manifest"
        },
        {
            "location": "/ref/package/#name",
            "text": "Required . The name of the Craftr package. This name must only consist of\nletters, digits, dots and underscores. The name of a package must be unique\nin the Craftr ecosystem, however if you are sure that you will never submit\nthe package to [Craftr.net], you can choose whatever you like.",
            "title": "name"
        },
        {
            "location": "/ref/package/#version",
            "text": "Required . A semantic versioning number for the package. This version number\nis used to find and load the correct package version when resoloving dependencies.\nNote that Craftr can load the same package multiple times, given they have\ndifferent version numbers.",
            "title": "version"
        },
        {
            "location": "/ref/package/#description",
            "text": "Optional . A short description of what the package does and what it is used\nfor.",
            "title": "description"
        },
        {
            "location": "/ref/package/#author",
            "text": "Optional . The name of the author of the package and optionally his/her email\naddress. If given, the email address should be enclosed in angle brackets, like \"John Peter <john.peter@fakemail.com>\" .",
            "title": "author"
        },
        {
            "location": "/ref/package/#url",
            "text": "Optional . URL to the project website. Most likely a link to the GitHub page.",
            "title": "url"
        },
        {
            "location": "/ref/package/#options",
            "text": "Optional . An object that describes available options for the package. The\nfields for this object are the option names. These fields again map to objects\nthat describe the option parameter  or  simply the option type name. Example:  options\":\n  directory: \"path\"\n  build_examples:\n    \"type\": \"bool\"\n    \"help\": \"Whether to build example files\"  Available fields:",
            "title": "options"
        },
        {
            "location": "/ref/package/#type",
            "text": "Require . The type of the option. Available option types are  \"bool\" , \"triplet\"  and  \"string\" .",
            "title": "type"
        },
        {
            "location": "/ref/package/#default",
            "text": "Optional . The default value of the option if no explicit value is defined.\nThe default value of this field depends on the option  type .",
            "title": "default"
        },
        {
            "location": "/ref/package/#help",
            "text": "Optional . A short description of what the option is used for.",
            "title": "help"
        },
        {
            "location": "/ref/package/#inherit",
            "text": "Optional . Defaults to  true . If this field is  true  and the value of the\noption is not defined explicitly, the global option with the same name will be\ninherited. For example if your package is called  some.cool.package  and the\noption name is  build_examples , then the full qualified option name would be some.cool.package.build_examples . Now if this option is not set but a global\noption  build_examples  is set, this value will be used for the option.",
            "title": "inherit"
        },
        {
            "location": "/ref/package/#dependencies",
            "text": "Optional . An object that describes the dependencies of the package. The\nfields of this object are the names of the required Craftr packages. The\nvalue of each field is a  version criteria , that is a string which specifies\none exact version number or a range of accepted version numbers. The format is\nsimilar to  npm  version selectors. Examples:  \"craftr.lib.curl\": \"*\"          // any version, but the newest we can get\n\"craftr.lib.curl\": \"=1.2.9\"     // exactly version 1.2.9\n\"craftr.lib.curl\": \"1.3 - 1.8\"  // any version between 1.3.0 and 1.8.0\n\"craftr.lib.curl\": \"2.x.2\"      // major and patch version 2, but any minor version  Note that Craftr will refuse to load modules with  load_module()  that are not\nlisted in the manifest  dependencies !   Important : Keep in mind that the version number defined in the dependencies  are the version numbers of Craftr packages, not necessarily\nthe version of the actual library that can be used with it.",
            "title": "dependencies"
        },
        {
            "location": "/ref/package/#main",
            "text": "Optional . The name of the build script. Usually you don't need/want to set\nthis field. The default value is  \"Craftrfile\" .",
            "title": "main"
        },
        {
            "location": "/ref/package/#project_dir",
            "text": "Optional . A relative path the alters the  project_dir  variable in the Craftr\nbuild script. This influences the way the  local()  built-in function behaves.\nFor more information on built-in functions, see the  Builtins documentation .  Note that you usually want this field to be set to  \"..\"  if you are using the\nnested project structure. The  craftr startpackage  command has a  -n/--nested \noption which creates a nested project structure and also sets this  project_dir \nfield.",
            "title": "project_dir"
        },
        {
            "location": "/ref/targets/",
            "text": "Targets\n\n\nIn Craftr, build targets are represented by the \ncraftr.core.build.Target\n\nclass. Instances of this class are usually not created directly, but instead\nby using a \ncraftr.targetbuilder.TargetBuilder\n object. A target contains the\nfollowing information:\n\n\n\n\nA \nname\n that is unique to the entire build process. This name is exported\n  as a phony target to the Ninja manifest, allowing you to specifically select\n  the target to be built from the command-line.\n\n\nOne or more \ncommands\n that are executed by Ninja to create the \noutputs\n\n  from the \ninputs\n (eg. compile a source file into an object file, link an\n  executable, create an archive from a list of files, etc.)\n\n\nLists of filenames for the \ninputs\n and \noutputs\n, \nimplicit_deps\n\n  and \norder_only_deps\n.\n\n\nA boolean flag that marks the Target as \nexplicit\n (thus, it is only built\n  when required by another target or specified on the command-line).\n\n\nA boolean flag that specifies whether the Target operates on the \ninputs\n\n  and \noutputs\n in a \nforeach\n manner, or if the command is only executed.\n\n\nOptionally, \ncwd\n  as the path to an alternate working directory when the\n  \ncommands\n are executed.\n\n\nAn \nenviron\n dictionary with additional environment variables to be set\n  before the \ncommands\n are executed.\n\n\nA list of \nframeworks\n that should be taken into account when the Target is\n  treated as an input to another target. See the \nFrameworks\n\n  Documentation for more information.\n\n\n\n\n... and a few more less commonly used things.\n\n\nUsing the TargetBuilder\n\n\nCreating a Target directly is not very common as there is quite a few things\nto handle to make Craftr's target generator functions as convenient as they\nare. Many target generators support retrieving options from a list of\nFrameworks and additionally from keyword-arguments specified to the generator\nfunction.\n\n\nThis is an example function that uses the \nTargetBuilder\n to create a target\nfrom a list of input source files and additional options.\n\n\n1)   def compile(sources, output, frameworks=(), name=None, **kwargs):\n2)     builder = TargetBuilder(gtn(name, 'compile'), kwargs, frameworks, sources, [output])\n3)     include = builder.get_list('include')\n4)     debug = builder.get('debug', options.debug)\n\n5)     command = ['gcc', '$in', '-o', '$out']\n       command += ['-I{}'.format(x) for x in include]\n       if debug:\n         command += ['-g', '-O0']\n\n6)     return builder.build([command])\n\n\n\n\nLet's look at what's happening here step-by-step.\n\n\n\n\ndef compile()\n defines a new Python function. It accepts 4 positional\n   arguments, two of which must always be specified. Also, it accepts\n   arbitrary keyword arguments. These will be taken into account together with\n   the \nFrameworks\n and take absolute precedence should a parameter appear\n   multiple times.\n\n\nWe create a TargetBuilder with all that information. Note how we use\n   \ngtn(name, 'compile')\n to find the actual target name. It will attempt\n   to determine the name from the variable that the result of \ncompile()\n\n   is being assigned. If it can not, it will default to the name \n'compile_XXXX'\n\n   where \nXXXX\n is a numeric suffix to avoid collisions.\n\n\nWe retrieve the option \ninclude\n from the \n**kwargs\n and the \nframeworks\n\n   that have been passed to the \ncompile()\n function. Using \nget_list()\n will\n   concatenate all values that can be found in all Frameworks.\n\n\nWe retrieve the option \ndebug\n. This will return the first value that is\n   found, or otherwise the second argument as a fallback (defaults to \nNone\n).\n   Note that we can only use \noptions.debug\n if it has been specified as an\n   option in the manifest of our package that provides the \ncompile()\n function.\n\n\nCreate some useful command to compile the source files. Note how \n$in\n and\n   \n$out\n are used to reference the \ninputs\n and \noutputs\n.\n\n\nCreate the actual Target from the specified list of commands (since we only\n  have a single command, we have to wrap it in an additional list).\n\n\n\n\nThe \ncompile()\n function could then be called like this:\n\n\ncurl = pkg_config('curl')\n\nmain = compile(\n  sources = glob('src/*.c'),\n  output = 'main',\n  include = [local('include')],\n  debug = True,\n  frameworks = [curl]\n)\n\n\n\n\nNote that if you pass keyword parameters that are not actually handled in the\ntarget generator function (ie. with \nbuilder.get()\n or \nget_list()\n), Craftr\nwill print a warning that the parameter is unused.\n\n\n\n\nNote\n\n\nThe above example would only work on a platform that provides GCC,\npkg-config and the cURL library.",
            "title": "Targets"
        },
        {
            "location": "/ref/targets/#targets",
            "text": "In Craftr, build targets are represented by the  craftr.core.build.Target \nclass. Instances of this class are usually not created directly, but instead\nby using a  craftr.targetbuilder.TargetBuilder  object. A target contains the\nfollowing information:   A  name  that is unique to the entire build process. This name is exported\n  as a phony target to the Ninja manifest, allowing you to specifically select\n  the target to be built from the command-line.  One or more  commands  that are executed by Ninja to create the  outputs \n  from the  inputs  (eg. compile a source file into an object file, link an\n  executable, create an archive from a list of files, etc.)  Lists of filenames for the  inputs  and  outputs ,  implicit_deps \n  and  order_only_deps .  A boolean flag that marks the Target as  explicit  (thus, it is only built\n  when required by another target or specified on the command-line).  A boolean flag that specifies whether the Target operates on the  inputs \n  and  outputs  in a  foreach  manner, or if the command is only executed.  Optionally,  cwd   as the path to an alternate working directory when the\n   commands  are executed.  An  environ  dictionary with additional environment variables to be set\n  before the  commands  are executed.  A list of  frameworks  that should be taken into account when the Target is\n  treated as an input to another target. See the  Frameworks \n  Documentation for more information.   ... and a few more less commonly used things.",
            "title": "Targets"
        },
        {
            "location": "/ref/targets/#using-the-targetbuilder",
            "text": "Creating a Target directly is not very common as there is quite a few things\nto handle to make Craftr's target generator functions as convenient as they\nare. Many target generators support retrieving options from a list of\nFrameworks and additionally from keyword-arguments specified to the generator\nfunction.  This is an example function that uses the  TargetBuilder  to create a target\nfrom a list of input source files and additional options.  1)   def compile(sources, output, frameworks=(), name=None, **kwargs):\n2)     builder = TargetBuilder(gtn(name, 'compile'), kwargs, frameworks, sources, [output])\n3)     include = builder.get_list('include')\n4)     debug = builder.get('debug', options.debug)\n\n5)     command = ['gcc', '$in', '-o', '$out']\n       command += ['-I{}'.format(x) for x in include]\n       if debug:\n         command += ['-g', '-O0']\n\n6)     return builder.build([command])  Let's look at what's happening here step-by-step.   def compile()  defines a new Python function. It accepts 4 positional\n   arguments, two of which must always be specified. Also, it accepts\n   arbitrary keyword arguments. These will be taken into account together with\n   the  Frameworks  and take absolute precedence should a parameter appear\n   multiple times.  We create a TargetBuilder with all that information. Note how we use\n    gtn(name, 'compile')  to find the actual target name. It will attempt\n   to determine the name from the variable that the result of  compile() \n   is being assigned. If it can not, it will default to the name  'compile_XXXX' \n   where  XXXX  is a numeric suffix to avoid collisions.  We retrieve the option  include  from the  **kwargs  and the  frameworks \n   that have been passed to the  compile()  function. Using  get_list()  will\n   concatenate all values that can be found in all Frameworks.  We retrieve the option  debug . This will return the first value that is\n   found, or otherwise the second argument as a fallback (defaults to  None ).\n   Note that we can only use  options.debug  if it has been specified as an\n   option in the manifest of our package that provides the  compile()  function.  Create some useful command to compile the source files. Note how  $in  and\n    $out  are used to reference the  inputs  and  outputs .  Create the actual Target from the specified list of commands (since we only\n  have a single command, we have to wrap it in an additional list).   The  compile()  function could then be called like this:  curl = pkg_config('curl')\n\nmain = compile(\n  sources = glob('src/*.c'),\n  output = 'main',\n  include = [local('include')],\n  debug = True,\n  frameworks = [curl]\n)  Note that if you pass keyword parameters that are not actually handled in the\ntarget generator function (ie. with  builder.get()  or  get_list() ), Craftr\nwill print a warning that the parameter is unused.   Note  The above example would only work on a platform that provides GCC,\npkg-config and the cURL library.",
            "title": "Using the TargetBuilder"
        },
        {
            "location": "/ref/tasks/",
            "text": "Tasks\n\n\nCraftr allows you to embed actual Python functions into the build process. We\ncall this concept \"tasks\". Tasks end up being plain rules and build instructions\nin the Ninja manifest. They will then be invoked using the \ncraftr run\n command.\nNote that for each task that is executed, your build-script is also executed\nanother time.\n\n\nYou can build functions that create tasks, so you can create multiple instances\nof the same task with different inputs, or you just create a task once from a\nsingle function.\n\n\nA simple example\n\n\ngit = load('craftr.utils.git').Git(project_dir)  # Git repository helper for this project\n\n@task(outputs = [buildlocal('include/gitversion.h')])\ndef gitversion(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n\n\n\nWe can then compile a C-program that includes the generated \ngitversion.h\n\nfile, but we must ensure that the task is executed \nbefore\n the C-program\nis compiled.\n\n\ncxx = load('craftr.lang.cxx')\napp = cxx.binary(\n  output = 'main',\n  inputs = cxx.c_compile(\n    sources = glob(['src/*.c']),\n    include = [buildlocal('include')]\n  ) << gitversion\n)\n\n\n\n\nTask generators\n\n\nWe can generalise the \ngitversion\n task so it can be used multiple times.\n\n\nGit = load('craftr.utils.git').Git  # Git repository helper for this project\n\ndef write_gitversion(project_dir = None):\n  if not project_dir:\n    project_dir = session.module.project_dir\n  git = Git(project_dir)\n\n  def worker(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n  outputs = [buildlocal('include/gitversion.h')]\n  return gentask(worker, outputs = outputs, name = gtn())\n\ngitversion = write_gitversion()",
            "title": "Tasks"
        },
        {
            "location": "/ref/tasks/#tasks",
            "text": "Craftr allows you to embed actual Python functions into the build process. We\ncall this concept \"tasks\". Tasks end up being plain rules and build instructions\nin the Ninja manifest. They will then be invoked using the  craftr run  command.\nNote that for each task that is executed, your build-script is also executed\nanother time.  You can build functions that create tasks, so you can create multiple instances\nof the same task with different inputs, or you just create a task once from a\nsingle function.",
            "title": "Tasks"
        },
        {
            "location": "/ref/tasks/#a-simple-example",
            "text": "git = load('craftr.utils.git').Git(project_dir)  # Git repository helper for this project\n\n@task(outputs = [buildlocal('include/gitversion.h')])\ndef gitversion(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))  We can then compile a C-program that includes the generated  gitversion.h \nfile, but we must ensure that the task is executed  before  the C-program\nis compiled.  cxx = load('craftr.lang.cxx')\napp = cxx.binary(\n  output = 'main',\n  inputs = cxx.c_compile(\n    sources = glob(['src/*.c']),\n    include = [buildlocal('include')]\n  ) << gitversion\n)",
            "title": "A simple example"
        },
        {
            "location": "/ref/tasks/#task-generators",
            "text": "We can generalise the  gitversion  task so it can be used multiple times.  Git = load('craftr.utils.git').Git  # Git repository helper for this project\n\ndef write_gitversion(project_dir = None):\n  if not project_dir:\n    project_dir = session.module.project_dir\n  git = Git(project_dir)\n\n  def worker(inputs, outputs):\n    with open(outputs[0], 'w') as fp:\n      fp.write('#pragma once\\n'\n              '#define GITVERSION \"{}\"\\n'\n        .format(git.describe()))\n\n  outputs = [buildlocal('include/gitversion.h')]\n  return gentask(worker, outputs = outputs, name = gtn())\n\ngitversion = write_gitversion()",
            "title": "Task generators"
        },
        {
            "location": "/ref/loaders/",
            "text": "If you're project provides some examples that depend on huge binary data,\nyou can download these files when necessary:\n\n\nif options.build_examples:\n  example_data = external_file(\"http://url.to/example/data.bin\")\n  # ... build examples here\n\n\n\n\nMany build scripts for projects that are not usually built with Craftr\nuse the \nexternal_archive()\n function to download a source archive and\nbuild from that.\n\n\nsource_directory = external_archive(\n  \"https://curl.haxx.se/download/curl-{}.tar.gz\".format(options.version)\n)\n\n# ...\n\n\n\n\nFor details on these functions, check the \nBuilt-ins Documentation",
            "title": "Loaders"
        },
        {
            "location": "/ref/builtins/",
            "text": "This document describes the available built-in data members and functions in\na \nCraftrfile\n build script. Except for the package-specific variables, all\nbuilt-in functions and classes are defined in the \ncraftr.defaults\n module.\n\n\nPackage-specific variables\n\n\nproject_dir\n\n\nThe project directory. This is usually the same as the directory of the\nCraftr package manifest (\nmanifest.cson\n), but can be altered with the\n\nproject_dir\n field in the manifest.\n\n\nThis variable has direct influence on the behaviour of the \nlocal()\n function.\n\n\noptions\n\n\nAn object that has as its members all options defined in the package manifest.\n\n\nif options.bad_weather:\n  logger.warn('be careful, you are choosing a build environment with bad weather')\n\n\n\n\nVariables\n\n\nlogger\n\n\nA \ncraftr.core.logging.BaseLogger\n instance. Use its \n.debug()\n, \n.info()\n,\n\n.warn()\n and \n.error()\n members to print information during the execution of\nthe build script.\n\n\nSee also: \nerror()\n built-in function\n\n\nsession\n\n\nThe current \ncraftr.core.session.Session\n object that manages the build process\nand Craftr packages. Sometimes you will want to modify its \n.options\n member\nor retrieve the currently executed Craftr module from its \n.module\n member.\n\n\nData\n\n\nDefault\n\n\nA singleton that can be used in places where \nNone\n can not be used as a\nplaceholder because it infers another special meaning. This is often used\nfor \nsuffix\n parameters of target generators.\n\n\nif suffix is Default:\n  suffix = derive_suffix_from_context()\nif suffix is not None:\n  output = path.addsuffix(output, suffix)\n\n\n\n\nFunctions\n\n\ngtn()\n\n\ninclude_defs()\n\n\nglob()\n\n\nlocal()\n\n\nbuildlocal()\n\n\nrelocate_files()\n\n\nfilter()\n\n\nmap()\n\n\nzip()\n\n\nload()\n\n\nload_file()\n\n\ngentool()\n\n\ngentarget()\n\n\ngentask()\n\n\ntask()\n\n\ngenalias()\n\n\nruntarget()\n\n\nwrite_response_file()\n\n\nerror()\n\n\nreturn_()\n\n\nappend_PATH()\n\n\nexternal_file(*urls, filename = None, directory = None, copy_file_urls = False, name = None)\n\n\nexternal_archive(*urls, directory = None, name = None)\n\n\npkg_config(pkg_name, static = False)\n\n\nUses \npkg-config\n to read the flags for the library specified with \npkg_name\n\nand returns a Framework object. If \npkg-config\n is not available on the platform\nor the library can not be found, \npkg_config.Error\n is raised.\n\n\nfrom craftr.loaders import pkg_config\ntry:\n  cURL = pkg_config('libcurl')\nexcept pkg_config.Error:\n  # compile from source or whatever\n\n\n\n\nClasses\n\n\nNamespace\n\n\nTargetBuilder\n\n\nFramework\n\n\nExceptions\n\n\nModuleError\n\n\nModuleReturn\n\n\nModuleNotFound\n\n\nToolDetectionError\n\n\nModules\n\n\npath\n\n\nshell\n\n\nplatform",
            "title": "Built-ins"
        },
        {
            "location": "/ref/builtins/#package-specific-variables",
            "text": "",
            "title": "Package-specific variables"
        },
        {
            "location": "/ref/builtins/#project_dir",
            "text": "The project directory. This is usually the same as the directory of the\nCraftr package manifest ( manifest.cson ), but can be altered with the project_dir  field in the manifest.  This variable has direct influence on the behaviour of the  local()  function.",
            "title": "project_dir"
        },
        {
            "location": "/ref/builtins/#options",
            "text": "An object that has as its members all options defined in the package manifest.  if options.bad_weather:\n  logger.warn('be careful, you are choosing a build environment with bad weather')",
            "title": "options"
        },
        {
            "location": "/ref/builtins/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/ref/builtins/#logger",
            "text": "A  craftr.core.logging.BaseLogger  instance. Use its  .debug() ,  .info() , .warn()  and  .error()  members to print information during the execution of\nthe build script.  See also:  error()  built-in function",
            "title": "logger"
        },
        {
            "location": "/ref/builtins/#session",
            "text": "The current  craftr.core.session.Session  object that manages the build process\nand Craftr packages. Sometimes you will want to modify its  .options  member\nor retrieve the currently executed Craftr module from its  .module  member.",
            "title": "session"
        },
        {
            "location": "/ref/builtins/#data",
            "text": "",
            "title": "Data"
        },
        {
            "location": "/ref/builtins/#default",
            "text": "A singleton that can be used in places where  None  can not be used as a\nplaceholder because it infers another special meaning. This is often used\nfor  suffix  parameters of target generators.  if suffix is Default:\n  suffix = derive_suffix_from_context()\nif suffix is not None:\n  output = path.addsuffix(output, suffix)",
            "title": "Default"
        },
        {
            "location": "/ref/builtins/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/ref/builtins/#gtn",
            "text": "",
            "title": "gtn()"
        },
        {
            "location": "/ref/builtins/#include_defs",
            "text": "",
            "title": "include_defs()"
        },
        {
            "location": "/ref/builtins/#glob",
            "text": "",
            "title": "glob()"
        },
        {
            "location": "/ref/builtins/#local",
            "text": "",
            "title": "local()"
        },
        {
            "location": "/ref/builtins/#buildlocal",
            "text": "",
            "title": "buildlocal()"
        },
        {
            "location": "/ref/builtins/#relocate_files",
            "text": "",
            "title": "relocate_files()"
        },
        {
            "location": "/ref/builtins/#filter",
            "text": "",
            "title": "filter()"
        },
        {
            "location": "/ref/builtins/#map",
            "text": "",
            "title": "map()"
        },
        {
            "location": "/ref/builtins/#zip",
            "text": "",
            "title": "zip()"
        },
        {
            "location": "/ref/builtins/#load",
            "text": "",
            "title": "load()"
        },
        {
            "location": "/ref/builtins/#load_file",
            "text": "",
            "title": "load_file()"
        },
        {
            "location": "/ref/builtins/#gentool",
            "text": "",
            "title": "gentool()"
        },
        {
            "location": "/ref/builtins/#gentarget",
            "text": "",
            "title": "gentarget()"
        },
        {
            "location": "/ref/builtins/#gentask",
            "text": "",
            "title": "gentask()"
        },
        {
            "location": "/ref/builtins/#task",
            "text": "",
            "title": "task()"
        },
        {
            "location": "/ref/builtins/#genalias",
            "text": "",
            "title": "genalias()"
        },
        {
            "location": "/ref/builtins/#runtarget",
            "text": "",
            "title": "runtarget()"
        },
        {
            "location": "/ref/builtins/#write_response_file",
            "text": "",
            "title": "write_response_file()"
        },
        {
            "location": "/ref/builtins/#error",
            "text": "",
            "title": "error()"
        },
        {
            "location": "/ref/builtins/#return_",
            "text": "",
            "title": "return_()"
        },
        {
            "location": "/ref/builtins/#append_path",
            "text": "",
            "title": "append_PATH()"
        },
        {
            "location": "/ref/builtins/#external_fileurls-filename-none-directory-none-copy_file_urls-false-name-none",
            "text": "",
            "title": "external_file(*urls, filename = None, directory = None, copy_file_urls = False, name = None)"
        },
        {
            "location": "/ref/builtins/#external_archiveurls-directory-none-name-none",
            "text": "",
            "title": "external_archive(*urls, directory = None, name = None)"
        },
        {
            "location": "/ref/builtins/#pkg_configpkg_name-static-false",
            "text": "Uses  pkg-config  to read the flags for the library specified with  pkg_name \nand returns a Framework object. If  pkg-config  is not available on the platform\nor the library can not be found,  pkg_config.Error  is raised.  from craftr.loaders import pkg_config\ntry:\n  cURL = pkg_config('libcurl')\nexcept pkg_config.Error:\n  # compile from source or whatever",
            "title": "pkg_config(pkg_name, static = False)"
        },
        {
            "location": "/ref/builtins/#classes",
            "text": "",
            "title": "Classes"
        },
        {
            "location": "/ref/builtins/#namespace",
            "text": "",
            "title": "Namespace"
        },
        {
            "location": "/ref/builtins/#targetbuilder",
            "text": "",
            "title": "TargetBuilder"
        },
        {
            "location": "/ref/builtins/#framework",
            "text": "",
            "title": "Framework"
        },
        {
            "location": "/ref/builtins/#exceptions",
            "text": "",
            "title": "Exceptions"
        },
        {
            "location": "/ref/builtins/#moduleerror",
            "text": "",
            "title": "ModuleError"
        },
        {
            "location": "/ref/builtins/#modulereturn",
            "text": "",
            "title": "ModuleReturn"
        },
        {
            "location": "/ref/builtins/#modulenotfound",
            "text": "",
            "title": "ModuleNotFound"
        },
        {
            "location": "/ref/builtins/#tooldetectionerror",
            "text": "",
            "title": "ToolDetectionError"
        },
        {
            "location": "/ref/builtins/#modules",
            "text": "",
            "title": "Modules"
        },
        {
            "location": "/ref/builtins/#path",
            "text": "",
            "title": "path"
        },
        {
            "location": "/ref/builtins/#shell",
            "text": "",
            "title": "shell"
        },
        {
            "location": "/ref/builtins/#platform",
            "text": "",
            "title": "platform"
        },
        {
            "location": "/ref/config/",
            "text": "Configuration values in Craftr are stored in the \nSession.options\n dictionary.\nThere are those options that are defined in Craftr packages and are automatically\nvalidated, but they are not limited by these definitions.\n\n\nNote that options that are not listed in Craftr package manifests do \nnot\n\nhave the \ninheriting\n behaviour, thus the full qualified option name must\nbe defined.\n\n\nOptions\n\n\ncraftr.ninja\n\n\nThe path or name of the Ninja executable to invoke. Defaults to the \nNINJA\n\nenvironment variable or simply \nninja\n.\n\n\nConfiguring\n\n\nOn the command-line, you can use the \n-d/--option\n argument to set options.\nThese options override every option read from configuration files. Alternatively,\nyou can specify one or more configuration files to load with the \n-c/--config\n\nargument. If none are specified, the file \n.craftrconfig\n in the current working\ndirectory is loaded if it exists.\n\n\nIf present, the file \n.craftrconfig\n in the users home directory will always\nbe loaded.\n\n\nConfiguration files are simple \n.ini\n files with two additions:\n\n\nInclude configuration files\n\n\nA configuration file can include another configuration file using the\n\ninclude\n section directive. Note that the \nif-exists\n portion is optional\nand can be used if you don't want it to be an error if the included file\ndoes not exist.\n\n\n[include \"path/to/file.ini\" if-exists]\n\n\n\n\nSetting global options\n\n\nThe \n[__global__]\n section can be used to define options without a prefix.\n\n\n[__global__]\ndebug = true",
            "title": "Build Configuration"
        },
        {
            "location": "/ref/config/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/ref/config/#craftrninja",
            "text": "The path or name of the Ninja executable to invoke. Defaults to the  NINJA \nenvironment variable or simply  ninja .",
            "title": "craftr.ninja"
        },
        {
            "location": "/ref/config/#configuring",
            "text": "On the command-line, you can use the  -d/--option  argument to set options.\nThese options override every option read from configuration files. Alternatively,\nyou can specify one or more configuration files to load with the  -c/--config \nargument. If none are specified, the file  .craftrconfig  in the current working\ndirectory is loaded if it exists.  If present, the file  .craftrconfig  in the users home directory will always\nbe loaded.  Configuration files are simple  .ini  files with two additions:",
            "title": "Configuring"
        },
        {
            "location": "/ref/config/#include-configuration-files",
            "text": "A configuration file can include another configuration file using the include  section directive. Note that the  if-exists  portion is optional\nand can be used if you don't want it to be an error if the included file\ndoes not exist.  [include \"path/to/file.ini\" if-exists]",
            "title": "Include configuration files"
        },
        {
            "location": "/ref/config/#setting-global-options",
            "text": "The  [__global__]  section can be used to define options without a prefix.  [__global__]\ndebug = true",
            "title": "Setting global options"
        },
        {
            "location": "/api/core/build/",
            "text": "craftr.core.build\n\n\n\n:mod:\ncraftr.core.build\n\n\nThis module provides all the API to generate a Ninja build manifest.\n\n\nGraph\n\n\n\nGraph()\n\n\n\n\nThis class represents the whole build graph which is generated from\ntargets reference input and output files. After a :class:\nTarget\n is\ncreated, it must be added to a Graph with the :meth:\nadd_target\n method.\n\n\nNote that all filenames in the Graph are absolute and normalized with\nthe :func:\npath.norm\n function.\n\n\n.. attribute:: tasks\n\n\nRead-only. A dictionary of all :class:\nTasks<Task>\n that have been\n  added to the Graph.\n\n\n.. attribute:: target\n\n\nRead-only. A dictionary of all the :class:\nTargets<Target>\n that have\n  been added to the Graph.\n\n\n.. attribute:: infiles\n\n\nRead-only. A dictionary that maps normalized filenames of input files\n  to a list of :class:\nTargets<Target>\n.\n\n\n.. attribute:: outfiles\n\n\nRead-only. A dictionary that maps normalized filenames of output files\n  to the :class:\nTarget\n that creates it.\n\n\n.. attributes:: vars\n\n\nA dictionary of variables that will be exported to the Ninja manifest.\n\n\nexport\n\n\n\nGraph.export(writer, context, platform)\n\n\n\n\nExport the build graph to a Ninja manifest.\n\n\n:param writer: A :class:\nninja_syntax.Writer\n object.\n:param context: A :class:\nExportContext\n object.\n:param platform: A :class:\nPlatformHelper\n instance.\n\n\nadd_tool\n\n\n\nGraph.add_tool(tool)\n\n\n\n\nAdd a :class:\nTool\n to the Graph.\n\n\n:raise ValueError: If the :attr:\nTool.name\n is already used.\n\n\nadd_target\n\n\n\nGraph.add_target(target)\n\n\n\n\nAdd a :class:\nTarget\n to the Graph.\n\n\n.. note:: For performance reasons, this method assumes that all paths\n          in the \ntarget\n are already normalized with :meth:\npath.norm\n.\n\n\n:raise ValueError: If the :attr:\nTarget.name\n is already used.\n:raise DuplicateOutputError: If the \ntarget\n lists an output file that\n  is already created by another target.\n\n\nadd_task\n\n\n\nGraph.add_task(task, **kwargs)\n\n\n\n\nAdd a :class:\nTask\n to the Graph. Creates a :class:\nTarget\n for the task\nand returns it.\n\n\n:param task: The :class:\nTask\n to add to the Graph.\n:param kwargs: Additional parameters for the :class:\nTarget\n constructor.\n\n\nPlatformHelper\n\n\n\nPlatformHelper(*args, **kwargs)\n\n\n\n\nInterface to abstract platfrom dependent operations during the export\nprocess.\n\n\nreplace_commands_inout_vars\n\n\n\nPlatformHelper.replace_commands_inout_vars(commands, inputs, outputs)\n\n\n\n\nApplies :meth:\nreplace_argument_inout_vars\n to all \ncommands\n.\n\n\nprepare_commands\n\n\n\nPlatformHelper.prepare_commands(commands)\n\n\n\n\nPassed a list of list of strings that represents the commands for\na target. Return the same value or a modified value.\n\n\nprepare_single_command\n\n\n\nPlatformHelper.prepare_single_command(command, cwd)\n\n\n\n\nGiven a single command as a list of strings and an optional working\ndirectory path, return an updated list of strings that serves as the\nnew command including the current working directory switch.\n\n\nreplace_argument_inout_vars\n\n\n\nPlatformHelper.replace_argument_inout_vars(arg, inputs, outputs)\n\n\n\n\nHelper function for :meth:\nwrite_command_file\n to replace the \n$in\n\nand \n$out\n variables in a command argument \narg\n with the specified\n\ninputs\n and \noutputs\n.\n\n\nwrite_command_file\n\n\n\nPlatformHelper.write_command_file(filename, commands, inputs=None, outputs=None, cwd=None, environ=None, foreach=False, suffix=Default, dry=False, accept_additional_args=False)\n\n\n\n\nWrites a file that can be run by the native shell to execute the \ncommands\n.\nIf \nsuffix\n is omitted, the default script suffix for the shell will be\nappended (which is especially important on Windows).\n\n\nReferences to \n$in\n and \n$out\n will be replaced by the values of\n\ninputs\n and \noutputs\n if they are specified. Note that in a concatenated\ncontext (eg. \n$out.d\n) the number input or output files (respectively)\nmust be exactly one, otherwise an error is raised.\n\n\nIf \nforeach\n is specified, the generated command file accepts two\ncommand-line arguments for the input and output file. Note that references\nto \n$in\n and \n$out\n will then be replaced by the respective placeholder\nin the shells scripting language and the \ninputs\n and \noutputs\n parmaeters\nare ignored.\n\n\nIf \naccept_additional_args\n is True, the last command in \ncommands\n must\naccept forward arguments passed to the shell script.\n\n\nReturns 1) a list of strings that represents the command to execute the\nscript. If \nforeach\n is specified, the two last items of the returned list\nwill be \n['$in', '$out']\n. 2) The actual filename that has been created.\n\n\nTool\n\n\n\nTool(name, command, preamble=None, environ=None)\n\n\n\n\nThis class represents a program that can be called by by the command in\nbuild rules. Usually this is only necessary if the tool requires a special\nenvironment.\n\n\nDepending on whether its necessary on the current platform, tools might be\nexported into shell scripts. The actual command to be called in the command\ncan then be retrieved by converting the :class:\nTool\n object to a string.\n\n\n.. attribute:: name\n\n\nThe name of the tool. In a build :class:\nGraph\n, there may only be one tool\n  associated with the same name.\n\n\n.. attribute:: command\n\n\nThe command that is to be executed and to which the additional command-line\n  arguments are forwarded to. Must be a list of strings.\n\n\n.. attribute:: preamble\n\n\nA list of commands/files that are to be sourced before the :attr:\ncommand\n\n  can be executed.\n\n\n.. attribute:: environ\n\n\nA dictionary of environment variables that will be exported before the\n  command or premable is executed.\n\n\n.. attribute:: exported_command\n\n\nAfter :meth:\nexported_command\n has been called, this member contains the\n  command that was exported for the Tool. This is a single string.\n\n\nExportContext\n\n\n\nExportContext(ninja_version)\n\n\n\n\nAn instance of this class is required for :meth:\nGraph.export\n and\n:meth:\nTarget.export\n. It provides additional information that can influence\nthe exported manifest.\n\n\n.. attribute:: ninja_version\n\n\nTask\n\n\n\nTask(name, func, args)\n\n\n\n\nRepresents a task that can be executed via \ncraftr run <task> <args...>\n.\nA task is a Python function that accepts arguments from the command-line.\n\n\nunpickle_args\n\n\n\nTask.unpickle_args(args)\n\n\n\n\nReverts :meth:\npickle_args\n.\n\n\npickle_args\n\n\n\nTask.pickle_args(args)\n\n\n\n\nConverts a list of arguments that may contain Python objects to a list of\nplain strings containing only printable characters. Python objects are\npickled, compressed and then encoded in base64.\n\n\nTarget\n\n\n\nTarget(name, commands, inputs, outputs, implicit_deps=(), order_only_deps=(), pool=None, deps=None, depfile=None, msvc_deps_prefix=None, explicit=False, foreach=False, description=None, metadata=None, cwd=None, environ=None, frameworks=(), task=None, runprefix=None)\n\n\n\n\nA higher level abstraction of a Target that can be added to a :class:\nGraph\n\nand then exported into a Ninja build manifest. A target should be treated\nas read-only always.\n\n\nexport\n\n\n\nTarget.export(writer, context, platform)\n\n\n\n\nExport the target to a Ninja manifest.\n\n\ngenerates_build_instruction\n\n\n\nReading this property tells you whether the target produces at least one\nbuild in the Ninja manifest. This is used to determine whether a target is\nincluded in the list of default targets or not.\n\n\nDuplicateOutputError\n\n\n\nDuplicateOutputError(filename, new_target, target)\n\n\n\n\nThis exception is raised if the same output file would be built by\nmultiple targets.",
            "title": "build"
        },
        {
            "location": "/api/core/build/#modcraftrcorebuild",
            "text": "This module provides all the API to generate a Ninja build manifest.",
            "title": ":mod:craftr.core.build"
        },
        {
            "location": "/api/core/config/",
            "text": "craftr.core.config\n\n\n\nread_config_file\n\n\n\nread_config_file(filename, basedir=None, follow_include_directives=True)\n\n\n\n\nReads a configuration file and returns a dictionary of the values that\nit contains. The format is standard :mod:\nconfigparser\n \n.ini\n style,\nhowever this function supports \ninclude\n directives that can include\nadditional configuration files.\n\n\n::\n\n\n[include \"path/to/config.ini\"]            ; errors if the file does not exist\n  [include \"path/to/config.ini\" if-exists]  ; ignored if the file does not exist\n\n\n:param filename: The name of the configuration file to read.\n:param basedir: If \nfilename\n is not an absolute path or the base directory\n  should be altered, this is the directory of which to look for files\n  specified with \ninclude\n directives.\n:param follow_include_directives: If this is True, \ninclude\n directives\n  will be followed.\n:raise FileNotFoundError: If \nfilename\n does not exist.\n:raise InvalidConfigError: If the configuration format is invalid. Also\n  if any of the included files do not exist.\n:return: A dictionary. Section names are prepended to the option names.",
            "title": "config"
        },
        {
            "location": "/api/core/logging/",
            "text": "craftr.core.logging",
            "title": "logging"
        },
        {
            "location": "/api/core/manifest/",
            "text": "craftr.core.manifest\n\n\n\n:mod:\ncraftr.core.manifest\n\n\nThis module implemenets parsing and representing the manifest files of\nCraftr packages. Every Craftr package also provides a Craftr module which\ncan be loaded with the \nload_module()\n function.\n\n\nExample manifest:\n\n\n.. code:: json\n\n\n{\n    \"name\": \"username.packagename\",\n    \"version\": \"1.0.3\",\n    \"main\": \"Craftrfile\",\n    \"author\": \"User Name \nusername@nameuser.org\n\",\n    \"url\": \"https://github.com/username/packagename\",\n    \"dependencies\": {\n      \"another_user.another_package\": \"1.x\"\n    },\n    \"options\": {\n      \"directory\": \"path\",\n      \"version\": \"string\"\n    }\n  }\n\n\nBoolOption\n\n\n\nBoolOption(name, default=False, **kwargs)\n\n\n\n\nRepresents a boolean option. Supports the identifiers \"yes\", \"true\",\n\"1\", \"no\", \"false\" and \"0\".\n\n\nalias\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nBaseOption\n\n\nBaseOption(name, inherit=True, help=None, default=None)\n\n\n\n\nBase class for option value processors that convert and validate options\nfrom string values (usually provided via the command-line or environment\nvariables).\n\n\n.. attribute:: name\n\n\n.. attribute:: inherit\n\n\n.. attribute:: help\n\n\n.. attribute:: default\n\n\nInvalidManifest\n\n\n\nInvalidManifest(*args, **kwargs)\n\n\n\n\nThis exception can be raised by :meth:\nManifest.parse\n\n\nTripletOption\n\n\n\nTripletOption(name, default=False, **kwargs)\n\n\n\n\nJust like the :class:\nBoolOption\n but with a third option, accepting\n\"null\" and \"none\" (which maps to :const:\nNone\n).\n\n\nalias\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nvalidate_package_name\n\n\nvalidate_package_name(name)\n\n\n\n\nValidates the package \nname\n. A valid package name must consist only\nof letters, digits, hyphes, underscores and periods. The first character\nof a package must be a letter or digit.\n\n\n:raise ValueError: If \nname\n is not a valid package name.\n\n\nStringOption\n\n\n\nStringOption(name, default='', **kwargs)\n\n\n\n\nPlain-string option.\n\n\nalias\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nPathOption\n\n\nPathOption(name, default='', **kwargs)\n\n\n\n\nOption for paths. Relative paths are automatically converted to absolute\npaths. It is assumed that relative paths are specified relative to\n:attr:\nSession.maindir\n.\n\n\nalias\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nManifest\n\n\nManifest(filename, name, version, main='Craftrfile', project_dir='.', description=None, author=None, url=None, dependencies=None, options=None)\n\n\n\n\nRepresents the manifest of a Craftr package. The manifest contains the basic\ninformation about the package name, version and its dependencies, as well as\nits author and homepage URL.\n\n\n.. attribute:: name\n\n\nThe name of the Craftr package.\n\n\n.. attribute:: version\n\n\nThe version of the Craftr package. This must be a semantic version\n  number parsable by the :class:\nVersion\n class.\n\n\n.. attribute:: main\n\n\nThe name of the main build script that is executed for the package.\n  If this member is None, Craftr will interpret it as the default value\n  specified in the :class:\ncraftr.core.session.Session\n.\n\n\n.. attribute:: project_dir\n\n\nRelative path to the project directory. Local paths in the build script\n  are automatically assumed relative to this directory. Defaults to \n..\n.\n\n\n.. attribute:: author\n\n\nName of the package author.\n\n\n.. attribute:: url\n\n\nThe homepage of the project of this package.\n\n\n.. attribute:: dependencies\n\n\nA dictionary that maps package names to version critiera parsable by\n  the :class:\nVersionCriteria\n class. The criteria is very similar to\n  Node.js version selectors.\n\n\n.. attribute:: options\n\n\nA dictionary of options that can be provided by the user before\n  Craftr is being executed. The option name maps to a :class:\nBaseOption\n\n  instance.\n\n\n.. attribute:: filename\n\n\nNot a field in the JSON manifest. The filename of the loaded manifest.\n\n\nSchema\n\n\n\ndict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)\n\nget_options_namespace\n\n\nManifest.get_options_namespace(provider, errors=None)\n\n\n\n\nCreate a :class:\nNamespace\n object filled with the option values specified\nin the manifest where the option values are read from \nprovider\n.\n\n\n:param provider: A dictionary that provides option values.\n:param errors: A list to which tuples of error information will be\n  appended. The tuples are in the format (option, value, exc).\n:return Namespace\n\n\nparse\n\n\n\nManifest.parse(filename, format=None)\n\n\n\n\nParses a manifest file and returns a new :class:\nManifest\n object. If no\n\nformat\n is specified, the format is determined from the file suffix.\n\n\nArguments\n\n\n\n\nfilename (str)\n: The filename of a JSON or CSON file.\n\n\nformat (str)\n: The format to assume when parsing the file. By default, the\n  format is determined from the file suffix. Valid values are \n'json'\n\n  or \n'cson'\n.\n\n\n\n\nRaises\n\n\n\n\nInvalidManifest\n: If the file is not a valid JSON file or the manifest data\n  is invalid or inconsistent.\n\n\nValueError\n: If the \nformat\n can not be determined from the \nfilename\n.\n\n\n\n\nReturns\n\n\nManifest\n: The resulting manifest data.\n\n\nInvalidManifest\n\n\n\nManifest.InvalidManifest(*args, **kwargs)\n\n\n\n\nThis exception can be raised by :meth:\nManifest.parse\n\n\nNamespace\n\n\n\nNamespace(*args, **kwargs)\n\n\n\n\nAn empty class which is used to assign arbitrary attributes to. An instance\nof this class is created by :meth:\nManifest.get_options_namespace\n.",
            "title": "manifest"
        },
        {
            "location": "/api/core/manifest/#modcraftrcoremanifest",
            "text": "This module implemenets parsing and representing the manifest files of\nCraftr packages. Every Craftr package also provides a Craftr module which\ncan be loaded with the  load_module()  function.  Example manifest:  .. code:: json  {\n    \"name\": \"username.packagename\",\n    \"version\": \"1.0.3\",\n    \"main\": \"Craftrfile\",\n    \"author\": \"User Name  username@nameuser.org \",\n    \"url\": \"https://github.com/username/packagename\",\n    \"dependencies\": {\n      \"another_user.another_package\": \"1.x\"\n    },\n    \"options\": {\n      \"directory\": \"path\",\n      \"version\": \"string\"\n    }\n  }",
            "title": ":mod:craftr.core.manifest"
        },
        {
            "location": "/api/core/renames/",
            "text": "craftr.core.renames\n\n\n\nThis module contains renames of STL modules to retain backwards compatibility.",
            "title": "renames"
        },
        {
            "location": "/api/core/session/",
            "text": "craftr.core.session\n\n\n\n:mod:\ncraftr.core.session\n\n\nThis module provides the :class:\nSession\n class which manages the loading\nprocess of Craftr modules and contains all the important root datastructures\nfor the meta build process (such as a :class:\ncraftr.core.build.Graph\n).\n\n\nSession\n\n\n\nSession(maindir=None)\n\n\n\n\nThis class manages the :class:\nbuild.Graph\n and loading of Craftr modules.\n\n\n.. attribute:: graph\n\n\nA :class:\nbuild.Graph\n instance.\n\n\n.. attribute:: path\n\n\nA list of paths that will be searched for Craftr modules.\n\n\n.. attribute:: module\n\n\nThe Craftr module that is currently being executed. This is an instance\n  of the :class:\nModule\n class and the same as the tip of the\n  :attr:\nmodulestack\n.\n\n\n.. attribute:: modulestack\n\n\nA list of modules where the last element (tip) is the module that is\n  currently being executed.\n\n\n.. attribute:: modules\n\n\nA nested dictionary that maps from name to a dictionary of version\n  numbers mapping to :class:\nModule\n objects. These are the modules that\n  have already been loaded into the session or that have been found and\n  cached but not yet been executed.\n\n\n.. attribute:: preferred_versions\n\n\nA nested dictionary with the same structure as :attr:\nmodules\n. This\n  dictionary might have been loaded from a dependency lock file and specifies\n  the preferred version to load for a specific module, assuming that the\n  criteria specified in the loading module's manifest is less strict. Note\n  that Craftr will error if a preferred version can not be found.\n\n\n.. attribute:: maindir\n\n\nThe main directory from which Craftr was run. Craftr will switch to the\n  build directory at a later point, which is why we keep this member for\n  reference.\n\n\n.. attribute:: builddir\n\n\nThe absolute path to the build directory.\n\n\n.. attribute:: main_module\n\n\nThe main :class:\nModule\n.\n\n\n.. attribute:: options\n\n\nA dictionary of options that are passed down to Craftr modules.\n\n\n.. attributes:: cache\n\n\nA JSON object that will be loaded from the current workspace's cache\n  file and written back when Craftr exits without errors. The cache can\n  contain anything and can be modified by everything, however it should\n  be assured that no name conflicts and accidental modifications/deletes\n  occur.\n\n\nReserved keywords in the cache are \n\"build\"\n and \n\"loaders\"\n.\n\n\nexpand_relative_options\n\n\n\nSession.expand_relative_options(module_name=None)\n\n\n\n\nAfter the main module has been detected, relative option names (starting\nwith \n.\n) should be converted to absolute option names. This is what\nthe method does.\n\n\nstl_dir\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nget_temporary_directory\n\n\nSession.get_temporary_directory()\n\n\n\n\nReturns a writable temporary directory that is primarily used by loaders\nto store temporary files. The temporary directory will be deleted when\nthe Session context ends unless the \ncraftr.keep_temporary_directory\n\noption is set.\n\n\n:raise RuntimeError: If the session is not currently in context.\n\n\nfind_module\n\n\n\nSession.find_module(name, version, resolve_preferred_version=True)\n\n\n\n\nFinds a module in the :attr:\npath\n matching the specified \nname\n and\n\nversion\n.\n\n\n:param name: The name of the module.\n:param version: A :class:\nVersionCriteria\n, :class:\nVersion\n or string\n  in a VersionCritiera format.\n:param resolve_preferred_version: If this parameter is True (default)\n  and a preferred version is specified in :attr:\npreferred_versions\n,\n  that preferred version is loaded or :class:\nModuleNotFound\n is raised.\n:raise ModuleNotFound: If the module can not be found.\n:return: :class:\nModule\n\n\nstl_auxiliary_dir\n\n\n\nstr(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.\nstr\n() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\nparse_manifest\n\n\nSession.parse_manifest(filename)\n\n\n\n\nParse a manifest by filename and add register the module to the module\ncache. Returns the :class:\nModule\n object. If the manifest has already\nbeen parsed, it will not be re-parsed.\n\n\n:raise Manifest.Invalid: If the manifest is invalid.\n:return: :const:\nNone\n if the manifest is a duplicate of an already\n  parsed manifest (determined by name and version), otherwise the\n  :class:\nModule\n object for the manifest's module.\n\n\nModule\n\n\n\nModule(directory, manifest)\n\n\n\n\nThis class represents a Craftr module that has been or is currently being\nexecuted. Every module has a project directory and a manifest with some\nbasic information on the module such as its name, version, but also things\nlike its dependencies and options.\n\n\nEvery Craftr project (i.e. module) contains a \nmanifest.json\n file\nand the main \nCraftrfile\n.\n\n\n::\n\n\nmyproject/\n    include/\n    source/\n    Craftrfile\n    manifest.json\n\n\n.. attribute:: directory\n\n\nThe directory that contains the \nmanifest.json\n. Note that the actual\n  project directory depends on the :attr:\nManifest.project_dir\n member.\n\n\n.. attribute:: ident\n\n\nA concentation of the name and version defined in the :attr:\nmanifest\n.\n\n\n.. attribute:: project_dir\n\n\nPath to the project directory as specified in the :attr:\nmanifest\n.\n\n\n.. attribute:: manifest\n\n\n.. attribute:: namespace\n\n\n.. attribute:: executed\n\n\nTrue if the module was executed with :meth:\nrun\n.\n\n\n.. attribute:: options\n\n\nA :class:\n~craftr.core.manifest.Namespace\n that contains all the options\n  for the module. This member is only initialized when the module is run\n  or with :meth:\ninit_options\n.\n\n\n.. attribute:: dependent_files\n\n\nA list of all files that influence the state of the module. This list\n  is generated when the module is executed with :func:\nrun\n. By default,\n  it contains at least the filename of the :attr:\nmanifest\n and the script\n  file that is executed for the Module. Additional files might be added\n  by some built-in functions like :func:\ncraftr.defaults.load_file\n.\n\n\n.. attribute:: dependencies\n\n\nA dictionary that maps a dependency name to an actual version. This\n  dictionary may contain only a subset of the dependencies listed in the\n  modules manifest as the module may only load some of the dependencies.\n\n\ncurrent_line\n\n\n\nThis property is only accessible when the module is currently begin\nexecuted, and only from within the same thread. Returns the line at\nwhich the module is currently being executed.\n\n\nrun\n\n\n\nModule.run()\n\n\n\n\nLoads the code of the main Craftr build script as specified in the modules\nmanifest and executes it. Note that this must occur in a context where\nthe :data:\nsession\n is available.\n\n\n:raise RuntimeError: If there is no current :data:\nsession\n or if the\n  module was already executed.\n\n\nget_init_globals\n\n\n\nModule.get_init_globals()\n\n\n\n\nReturns a dictionary initialized with the default built-in values for a\nbuild script.\n\n\ninit_options\n\n\n\nModule.init_options(recursive=False, _break_recursion=None)\n\n\n\n\nInitialize the :attr:\noptions\n member. Requires an active session context.\n\n\n:param recursive: Initialize the options of all dependencies as well.\n:raise InvalidOption: If one or more options are invalid.\n:raise ModuleNotFound: If \nrecursive\n is specified and a dependency\n  was not found.\n:raise RuntimeError: If there is no current session context.",
            "title": "session"
        },
        {
            "location": "/api/core/session/#modcraftrcoresession",
            "text": "This module provides the :class: Session  class which manages the loading\nprocess of Craftr modules and contains all the important root datastructures\nfor the meta build process (such as a :class: craftr.core.build.Graph ).",
            "title": ":mod:craftr.core.session"
        },
        {
            "location": "/api/platform/",
            "text": "craftr.platform",
            "title": "platform"
        },
        {
            "location": "/api/utils/argspec/",
            "text": "craftr.utils.argspec\n\n\n\nvalidate\n\n\n\nvalidate(name, value, schema)\n\n\n\n\nA helper function to validate function parameters type and value.\nThe \nschema\n must be a dictionary and supports the following keys:\n\n\n\n\ntype\n: A single type or a list of accepted types\n\n\nbool_validators\n: A function or a list of functions that return\n  True if the \nvalue\n is valid, False otherwise.\n\n\nvalidators\n: A function or a list of functions that raise a\n  :class:\nValueError\n if the \nvalue\n is invalid.\n\n\nitems\n: If \nvalue\n is a sequence, this key must provide a sub-schema\n  that holds true for all of the items in the sequence. Note that it will\n  not be applied to iterables.\n\n\nallowEmpty\n: If specified, must be True or False. If True, allows\n  \nvalue\n to be an empty sequence, otherwise not.",
            "title": "argspec"
        },
        {
            "location": "/api/utils/cson/",
            "text": "craftr.utils.cson\n\n\n\nA wrapper around the #!cson module which wraps all exceptions in a common\n\nError\n exception type and gives proper error messages.\n\n\nload\n\n\n\nload(*args, **kwargs)\n\n\n\n\nWrapper for #!cson.load(). Accepts an additional \nfilename\n parameter that\nwill be included in the error message.",
            "title": "cson"
        },
        {
            "location": "/api/utils/httputils/",
            "text": "craftr.utils.httputils\n\n\n\nparse_content_disposition\n\n\n\nparse_content_disposition(value)\n\n\n\n\nParse the \nContent-Disposition\n header.\n\n\nUserInterrupt\n\n\n\nUserInterrupt(*args, **kwargs)\n\n\n\n\nAn exception that represents the intended abortion of an operation.\n\n\ndownload_file\n\n\n\ndownload_file(url, filename=None, file=None, directory=None, on_exists='rename', progress=None, chunksize=4096, urlopen_kwargs=None)\n\n\n\n\nDownload a file from a URL to one of the following destinations:\n\n\n:param filename: A filename to write the downloaded file to.\n:param file: A file-like object.\n:param directory: A directory. The filename will be automatically\n  determined from the \nContent-Disposition\n header received from\n  the server or the last path elemnet in the URL.\n\n\nAdditional parameters for the \ndirectory\n parameter:\n\n\n:param on_exists: The operation to perform when the file already exists.\n  Available modes are \nrename\n, \noverwrite\n and \nskip\n.\n\n\nAdditional parameters:\n\n\n:param progress: A callable that accepts a single parameter that is a\n  dictionary with information about the progress of the download. The\n  dictionary provides the keys \nsize\n,  \ndownloaded\n and \nresponse\n.\n  If the callable returns :const:\nFalse\n (specifically the value False), the\n  download will be aborted and a :class:\nUserInterrupt\n will be raised.\n:param urlopen_kwargs: A dictionary with additional keyword arguments\n  for :func:\nurllib.request.urlopen\n.\n\n\nRaise and return:\n\n\n:raise HTTPError: Can be raised by :func:\nurllib.request.urlopen\n.\n:raise URLError: Can be raised by :func:\nurllib.request.urlopen\n.\n:raise UserInterrupt: If the \nprogress\n returned :const:\nFalse\n.\n:return: If the download mode is \ndirectory\n, the name of the downloaded\n  file will be returned and False if the file was newly downloaded, True\n  if the download was skipped because the file already existed.\n  Otherwise, the number of bytes downloaded will be returned.",
            "title": "httputils"
        },
        {
            "location": "/api/utils/path/",
            "text": "craftr.utils.path\n\n\n\neasy_listdir\n\n\n\neasy_listdir(directory)\n\n\n\n\nA friendly version of :func:\nos.listdir\n that does not error if the\n\ndirectory\n doesn't exist.\n\n\nrmvsuffix\n\n\n\nrmvsuffix(subject)\n\n\n\n\nRemove the suffix from \nsubject\n.\n\n\ncommon\n\n\n\ncommon(paths)\n\n\n\n\nReturns the longest sub-path of each path in the \npaths\n list. If \npaths\n is\nempty, contains mixed absolute/relative paths or the paths have no common\npath, a :class:\nValueError\n is raised.\n\n\nIf there is only one element in \npaths\n, its parent directory is returned.\n\n\nnorm\n\n\n\nnorm(path, parent=None)\n\n\n\n\nNormalizes the specified \npath\n. This turns it into an absolute path and\nremoves all superfluous path elements. Similar to :func:\nos.path.normpath\n,\nbut accepts a \nparent\n argument which is considered when \npath\n is relative.\n\n\ntransition\n\n\n\ntransition(filename, oldbase, newbase)\n\n\n\n\nTranslates the \nfilename\n from the directory \noldbase\n to the new\ndirectory \nnewbase\n. This is identical to finding the relative path\nof \nfilename\n to \noldbase\n and joining it with \nnewbase\n. The \nfilename\n\nmust be a sub-path of \noldbase\n.\n\n\n.. code:: python\n\n\n\n\n\n\n\n\ntransition('src/main.c', 'src', 'build/obj')\n  build/obj/main.c\n\n\n\n\n\n\n\n\nmakedirs\n\n\n\nmakedirs(path)\n\n\n\n\nLike :func:\nos.makedirs\n, but this function does not raise an exception\nwhen the directory at \npath\n already exists.\n\n\naddprefix\n\n\n\naddprefix(subject, prefix)\n\n\n\n\nAdds the specified \nprefix\n to the last path element in \nsubject\n.\nIf \nprefix\n is a callable, it must accept exactly one argument, which\nis the last path element, and return a modified value.\n\n\nissub\n\n\n\nissub(path)\n\n\n\n\nReturns True if \npath\n is a relative path that does not point outside\nof its parent directory or is equal to its parent directory (thus, this\nfunction will also return False for a path like \n./\n).\n\n\nsetsuffix\n\n\n\nsetsuffix(subject, suffix)\n\n\n\n\nSynonymous for passing the True for the \nreplace\n parameter in\n:func:\naddsuffix\n.\n\n\nrel\n\n\n\nrel(path, parent=None, nopar=False)\n\n\n\n\nLike :func:\nos.path.relpath\n, but the \nnopar\n parameter can be set to return\nan absolute path if the relative path would create a path element that\nreferences a parent directory (\n..\n) or current directory (\n.\n).\n\n\nglob\n\n\n\nglob(patterns, parent=None, excludes=(), include_dotfiles=False, ignore_false_excludes=False)\n\n\n\n\nWrapper for :func:\nglob2.glob\n that accepts an arbitrary number of\npatterns and matches them. The paths are normalized with :func:\nnorm\n.\n\n\nRelative patterns are automaticlly joined with \nparent\n. If the\nparameter is omitted, it defaults to the currently executed build\nscripts project directory.\n\n\nIf \nexcludes\n is specified, it must be a string or a list of strings\nthat is/contains glob patterns or filenames to be removed from the\nresult before returning.\n\n\n.. note::\n\n\nEvery file listed in \nexcludes\n will only remove \none\n item from\n  the result list that was generated from \npatterns\n. Thus, if you\n  want to exclude some files with a pattern except for a specific file\n  that would also match that pattern, simply list that file another\n  time in the \npatterns\n.\n\n\n:param patterns: A list of glob patterns or filenames.\n:param parent: The parent directory for relative paths.\n:param excludes: A list of glob patterns or filenames.\n:param include_dotfiles: If True, \n*\n and \n**\n can also capture\n  file or directory names starting with a dot.\n:param ignore_false_excludes: False by default. If True, items listed\n  in \nexcludes\n that have not been globbed will raise an exception.\n:return: A list of filenames.\n\n\ngetimtime\n\n\n\ngetimtime(path)\n\n\n\n\nJust like :func:\ngetmtime()\n, but rounds down to an integer.\n\n\nget_long_path_name\n\n\n\nget_long_path_name(path)\n\n\n\n\nThis function is important when using Craftr on platforms with\ncase-insenstive filesystem, such as Windows. It returns the correct\ncapitalization for \npath\n, given that it exists. For other platforms,\nthe \npath\n is returned as-is.\n\n\nIf \npath\n does not exist, it is returned unchanged in any case.\n\n\naddsuffix\n\n\n\naddsuffix(subject, suffix, replace=False)\n\n\n\n\nAdds the specified \nsuffix\n to the \nsubject\n. If \nreplace\n is True, the\nold suffix will be removed first. If \nsuffix\n is callable, it must accept\nexactly one argument and return a modified value.\n\n\nremove\n\n\n\nremove(path, recursive=False, silent=False)\n\n\n\n\nLike :func:\nos.remove\n, but the \nsilent\n parmaeter can be specified to\nprevent the function from raising an exception if the \npath\n could not be\nremoved. Also, the \nrecursive\n parameter allows you to use this function\nto remove directories as well. In this case, :func:\nshutil.rmtree\n is\nused.\n\n\ngetsuffix\n\n\n\ngetsuffix(subject)\n\n\n\n\nReturns the suffix of a filename. If the file has no suffix, returns None.\nCan return an empty string if the filenam ends with a period.\n\n\nisglob\n\n\n\nisglob(path)\n\n\n\n\n:param path: The string to check\n:return bool: True if the path is a glob pattern, False otherwise.\n\n\ncanonical\n\n\n\ncanonical(path)\n\n\n\n\nA synonym for :meth:\nos.path.normpath\n.\n\n\ntempfile\n\n\n\ntempfile(suffix='', prefix='tmp', dir=None, text=False)\n\n\n\n\nA better temporary file class where the \nclose()\n function does not delete\n  the file but only \n__exit__()\n does. Obviously, this allows you to close\n  the file and re-use it with some other processing before it finally gets\n  deleted.\n\n\nThis is especially important on Windows because apparently another\n  process can't read the file while it's still opened in the process\n  that created it.\n\n\npython\n  from craftr.tools import tempfile\n  with tempfile(suffix='c', text=True) as fp:\n    fp.write('`include` <stdio.h>\nint main() { }\n')\n    fp.close()\n    shell.run(['gcc', fp.name])\n\n\n@param suffix: The suffix of the temporary file.\n  @param prefix: The prefix of the temporary file.\n  @param dir: Override the temporary directory.\n  @param text: True to open the file in text mode. Otherwise, it\n    will be opened in binary mode.\n\n\nmaybedir\n\n\n\nmaybedir(path)\n\n\n\n\nReturns True if \npath\n ends with a separator. This information can be used\nto interpret a path as a directory or a filename only from its\nrepresentation.\n\n\n.. code:: python\n\n\n\n\n\n\n\n\nmaybedir('foobar/')\n  True\nmaybedir('foo/bar')\n  False",
            "title": "path"
        },
        {
            "location": "/api/utils/pyutils/",
            "text": "craftr.utils.pyutils\n\n\n\ncopyfileobj\n\n\n\ncopyfileobj(sfp, dfp, size=None, chunksize=4096)\n\n\n\n\nGenerator that yields the progress after every chunk has been copied\nfrom \nsfp\n to \ndfp\n. If \nsize\n is not specified, \nsfp\n will be seeked\nfirst. The yielded progress is a tuple of \n(bytes_copied, size)\n.\n\n\nflatten\n\n\n\nflatten(iterable)\n\n\n\n\nFlattens two levels of nested iterables into a single list.\n\n\nimport_\n\n\n\nimport_(fqn)\n\n\n\n\nGiven a fully qualified name, imports the object and returns it.\n\n\n:param fqn: The full name of the object to import, including the module\n  name to import it from.\n:raise ImportError: If the object can not be imported.\n:return: any\n\n\ncombine_context\n\n\n\ncombine_context(*inputs)\n\n\n\n\nCombines multiple context managers.\n\n\nstrip_flags\n\n\n\nstrip_flags(command, flags)\n\n\n\n\nRemove all occurences of all \nflags\n in the \ncommand\n list. The list is\nmutated directlry.\n\n\n:param command: A list of command-line arguments.\n:param remove_flags: An iterable of flags to remove.\n:return: The \ncommand\n parameter.",
            "title": "pyutils"
        },
        {
            "location": "/api/utils/shell/",
            "text": "craftr.utils.shell\n\n\n\nTimeoutExpired\n\n\n\nTimeoutExpired(process, timeout)\n\n\n\n\nThis exception is raised when a process did not exit after a\nspecific timeout. If this exception was raised, the child process\nhas already been killed.\n\n\ntest_program\n\n\n\ntest_program(name)\n\n\n\n\nUses :func:\nfind_program\n to find the path to \nname\n and returns\nTrue if it could be found, False otherwise.\n\n\njoin\n\n\n\njoin(cmd, for_ninja=False)\n\n\n\n\nJoin a list of strings to a single command string.\n\n\nrun\n\n\n\nrun(cmd, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, cwd=None, env=None, encoding='utf-8')\n\n\n\n\nRun the process with the specified \ncmd\n. If \ncmd\n is a list of\ncommands and \nshell\n is True, the list will be automatically converted\nto a properly escaped string for the shell to execute.\n\n\n.. note::\n\n\nIf \"shell\" is True, this function will manually check if the file\n  exists and is executable first and raise :class:\nFileNotFoundError\n\n  if not.\n\n\n:raise CalledProcessError: If \ncheck\n is True and the process exited with\n  a non-zero exit-code.\n:raise TimeoutExpired: If \ntimeout\n was specified and the process did not\n  finish before the timeout expires.\n:raise OSError: For some OS-level error, eg. if the program could not be\n    found.\n\n\nformat\n\n\n\nformat(fmt, *args, **kwargs)\n\n\n\n\n\"\n  Similar to :meth:\nstr.format\n, but this function will escape all arguments\n  with the :func:\nquote\n function. This is useful to easily generate commands.\n\n\n.. code:: python\n\n\n>>> format('gcc {} -o {}', 'my source/main.c', 'spaces are bad/main')\n'gcc \"my source/main.c\" -o \"spaces are bad/main\"'\n\n\n\n\nsplit\n\n\n\nsplit(s)\n\n\n\n\nEnhanced implementation of :func:\nshlex.split\n.\n\n\nfind_program\n\n\n\nfind_program(name)\n\n\n\n\nFinds the program \nname\n in the directories listed by the \nPATH\n\nenvironment variable and returns the full absolute path to it. On Windows,\nthis also takes the \nPATHEXT\n variable into account.\n\n\n:param name: The name of the program to find.\n:return: :class:\nstr\n -- The absolute path to the program.\n:raise FileNotFoundError: If the program could not be found in the PATH.\n:raise PermissionError: If a candidate for \"name\" was found but\n  it is not executable.\n\n\nsafe\n\n\n\nsafe(*args, **kwargs)\n\n\n\n\nIf this object is passed to \nquote()\n, it will not be escaped.\n\n\npipe\n\n\n\npipe(*args, merge=True, **kwargs)\n\n\n\n\nLike \nrun()\n, but pipes stdout and stderr to a buffer instead of\ndirecting them to the current standard out and error files. If \nmerge\n\nis True, stderr will be merged into stdout.\n\n\nCalledProcessError\n\n\n\nCalledProcessError(process)\n\n\n\n\nThis exception is raised when a process exits with a non-zero\nreturncode and the run was to be checked for such state. The exception\ncontains the process information.\n\n\nCompletedProcess\n\n\n\nCompletedProcess(cmd, returncode, stdout, stderr)\n\n\n\n\nThis class represents a completed process.\n\n\nquote\n\n\n\nquote(s, for_ninja=False)\n\n\n\n\nEnhanced implementation of :func:\nshlex.quote\n as it generates single-quotes\non Windows which can lead to problems.",
            "title": "shell"
        },
        {
            "location": "/api/utils/singleton/",
            "text": "craftr.utils.singleton\n\n\n\nmake_singleton\n\n\n\nmake_singleton(name, type_name=None, as_bool=True)\n\n\n\n\nCreate a single type and return its only instance with the\nspecified \nname\n. If \ntype_name\n is not specified, it is automatically\nderived from the singleton \nname\n.",
            "title": "singleton"
        },
        {
            "location": "/api/utils/tty/",
            "text": "craftr.utils.tty\n\n\n\n:mod:\ncraftr.utils.tty\n\n\nThis module provides colorized terminal output and other terminal helpers.\nIn order to colorize output, the :mod:\ntermcolor\n module is required. On\nWindows, the \ncolorama\n module is also necessary.\n\n\ncolored\n\n\n\ncolored(text, color=None, on_color=None, attrs=None)\n\n\n\n\nSynonym for :func:\ntermcolor.colored()\n that can also be used if the\nmodule is not available, in which case \ntext\n is returned unchanged.\n\n\nterminal_size\n\n\n\nterminal_size(default=(120, 30))\n\n\n\n\nDetermines the size of the terminal. If the size can not be obtained, returns\nthe specified \ndefault\n size.\n\n\ncompile\n\n\n\ncompile(color=None, on_color=None, attrs=None)\n\n\n\n\nCompile an ANSI escape sequence and return it. Return an empty string if\nthe :mod:\ntermcolor\n module is not available. To reset the styling, use the\n:data:\nreset\n string.\n\n\nclear_line\n\n\n\nclear_line()\n\n\n\n\nClears out the current line in the terminal completely and resets the\ncurser to the first column.",
            "title": "tty"
        },
        {
            "location": "/api/utils/tty/#modcraftrutilstty",
            "text": "This module provides colorized terminal output and other terminal helpers.\nIn order to colorize output, the :mod: termcolor  module is required. On\nWindows, the  colorama  module is also necessary.",
            "title": ":mod:craftr.utils.tty"
        },
        {
            "location": "/api/defaults/",
            "text": "craftr.defaults\n\n\n\n:mod:\ncraftr.defaults\n\n\nThis module provides the default global namespace for Craftr modules. Names\nstarting with an underscore will be ignored.\n\n\nwrite_response_file\n\n\n\nwrite_response_file(arguments, builder=None, name=None, force_file=False, suffix='')\n\n\n\n\nCreates a response-file with the specified \nname\n in the in the\n\nbuildfiles/\n directory and writes the \narguments\n list quoted into\nthe file. If \nbuilder\n is specified, it must be a :class:\nTargetBuilder\n\nand the response file will be added to the implicit dependencies.\n\n\nIf \nforce_file\n is set to True, a file will always be written. Otherwise,\nthe function will into possible limitations of the platform and decide\nwhether to write a response file or to return the \narguments\n as is.\n\n\nReturns a tuple of \n(filename, arguments)\n. If a response file is written,\nthe returned \narguments\n will be a list with a single string that is the\nfilename prepended with \n@\n. The \nfilename\n part can be None if no\nresponse file needed to be exported.\n\n\ngentool\n\n\n\ngentool(commands, preamble=None, environ=None, name=None)\n\n\n\n\nCreate a :class:\n~_build.Tool\n object. The name of the tool will be derived\nfrom the variable name it is assigned to unless \nname\n is specified.\n\n\nappend_PATH\n\n\n\nappend_PATH(*paths)\n\n\n\n\nThis is a helper function that is used to generate a \nPATH\n environment\nvariable from the value that already exists and add the specified \npaths\n\nto it. It is typically used for example like this:\n\n\n.. code:: python\n\n\nrun = gentarget(\n    commands = [[main, local('example.ini')]],\n    explicit=True,\n    environ = {'PATH': append_PATH(qt5.bin_dir if qt5 else None)}\n  )\n\n\nload_file\n\n\n\nload_file(filename, export_default_namespace=True)\n\n\n\n\nLoads a Python file into a new module-like object and returns it. The\n\nfilename\n is assumed relative to the currently executed module's\ndirectory (NOT the project directory which can be different).\n\n\ninclude_defs\n\n\n\ninclude_defs(filename, globals=None)\n\n\n\n\nUses :mod:\nload_file\n to load a Python file and then copies all symbols\nthat do not start with an underscore into the \nglobals\n dictionary. If\n\nglobals\n is not specified, it will fall back to the globals of the frame\nthat calls the function.\n\n\nbuildlocal\n\n\n\nbuildlocal(rel_path)\n\n\n\n\nGiven a relative path, returns the path (still relative) to the build\ndirectory for the current module. This is basically a shorthand for\nprepending the module name and version to \npath\n.\n\n\ngentask\n\n\n\ngentask(func, args=None, inputs=(), outputs=(), name=None, explicit=True, **kwargs)\n\n\n\n\nCreate a Task that can be embedded into the build chain. Tasks can have input\nand output files that cause the task to be embedded into the build chain. By\ndefault, tasks need to be explicitly built or required by other targets.\n\n\nIf \nargs\n is not specified, it will be replaced by \n[inputs, outputs]\n.\n\n\n:param func: A function to call to execute the task. It must accept a\n  variable number of arguments, which are the arguments passed via the \nargs\n\n  parameter. This function will be called from Ninja using the \ncraftr run\n\n  command.\n:param args: A list of arguments to pass to \nfunc\n. Note that non-string\n  arguments will be pickled, compressed and and encoded in base64, prefixed\n  with the string \npickle://\n. These will be unpickled when the task is run.\n  Note that \n$in\n and \n$out\n will be expanded in this argument list.\n:param inputs: A list of input files.\n:param inputs: A list of output files.\n:param name: Alternative target name.\n:param kwargs: Additional parameters for the :class:\nTask\n constructor.\n:return: A :class:\nTarget\n object.\n\n\ngentarget\n\n\n\ngentarget(commands, inputs=(), outputs=(), *args, **kwargs)\n\n\n\n\nCreate a :class:\n~_build.Target\n object. The name of the target will be\nderived from the variable name it is assigned to unless \nname\n is specified.\n\n\nlocal\n\n\n\nlocal(rel_path)\n\n\n\n\nGiven a relative path, returns the absolute path relative to the current\nmodule's project directory.\n\n\nglob\n\n\n\nglob(patterns, parent=None, exclude=(), include_dotfiles=False, ignore_false_excludes=False)\n\n\n\n\nWrapper for :func:\npath.glob\n that automatically uses the current modules\nproject directory for the \nparent\n argument if it has not been specifically\nset.\n\n\nerror\n\n\n\nerror(*message)\n\n\n\n\nRaises a :class:\nModuleError\n exception.\n\n\nruntarget\n\n\n\nruntarget(target, *args, inputs=(), outputs=(), **kwargs)\n\n\n\n\nSimplification of :func:\ngentarget\n to make it more obvious that a\ngenerate target is actually executed.\n\n\ngenalias\n\n\n\ngenalias(*targets, name=None, **kwargs)\n\n\n\n\nCreate a target that serves as an alias for all targets list in \ntargets\n.\n\n\nmap\n\n\n\nmap(procedure, iterable)\n\n\n\n\nAlternative for the built-in \nmap()\n function that returns a list instead\nof an iterable (which is the behaviour since Python 3).\n\n\ntask\n\n\n\ntask(inputs=(), outputs=(), args=None, **kwargs)\n\n\n\n\nGenerate a one-off task. Optionally you can specified a list of \ninputs\n\nand \noutputs\n. If \nargs\n is not specified, the \ninputs\n and \noutputs\n will\nbe passed as arguments to the task function. Otherwise, \nargs\n will be\npassed.\n\n\nreturn_\n\n\n\nreturn_()\n\n\n\n\nRaises a :class:\nModuleReturn\n exception.\n\n\nfilter\n\n\n\nfilter(predicate, iterable)\n\n\n\n\nAlternative for the built-in \nfilter()\n function that returns a list\ninstead of an iterable (which is the behaviour since Python 3).\n\n\nload\n\n\n\nload(name, into=None, mode='exports', _stackframe=1)\n\n\n\n\nLoad a Craftr module by name and return it. If \ninto\n is specified, it must\nbe a dictionary that will be filled with all the members of the module. Note\nthat this function returns the namespace object of the module rather than\nthe actual :class:\ncraftr.core.session.Module\n object that wraps the module\ninformation unless \nget_namespace\n is False.\n\n\nThe version criteria is read from the current module's manifest.\n\n\n:param name: The name of the module to load. If this name is suffixed\n  with the two characters \n.*\n and the \ninto\n parameter is :const:\nNone\n,\n  the contents of the module will be exported into the globals of the\n  calling frame.\n:param into: If specified, must be a dictionary.\n:param mode: One of \n'module'\n, \n'namespace'\n and \n'exports'\n. In module\n  mode, the :class:\ncraftr.core.session.Module\n will be returned. In namespace\n  mode, the namespace of that module will be returned. In exports mode, if\n  the namespace has a member named \n'exports'\n, that member will be returned,\n  otherwise it behaves the same as namespace mode. Defaults to \n'exports'\n.\n:return: The module namespace object (of type :class:\ntypes.ModuleType\n)\n  or the actual :class:\ncraftr.core.session.Module\n if \nget_namespace\n\n  is False.\n:raise ModuleNotFound: If the module could not be found.\n:raise RuntimeError: If the module that is attempted to be loaded is not\n  declared in the current module's manifest.\n\n\nModuleReturn\n\n\n\nModuleReturn(*args, **kwargs)\n\n\n\n\nThis exception is raised to \"return\" form a module execution pre-emptively\nwithout causing an error. See :func:\nreturn_()\n\n\nrelocate_files\n\n\n\nrelocate_files(files, outdir, suffix, replace_suffix=True, parent=None)\n\n\n\n\nConverts a list of filenames, relocating them to \noutdir\n and replacing\ntheir existing suffix. If \nsuffix\n is a callable, it will be passed the\nnew filename and expected to return the same filename, eventually with\na different suffix.\n\n\nzip\n\n\n\nzip(*iterables, fill=NotImplemented)\n\n\n\n\nAlternative to the Python built-in \nzip()\n function. This function returns\na list rather than an iterable and also supports swapping to the\n:func:\nitertools.izip_longest\n version if the \nfill\n parameter is specified.",
            "title": "defaults"
        },
        {
            "location": "/api/defaults/#modcraftrdefaults",
            "text": "This module provides the default global namespace for Craftr modules. Names\nstarting with an underscore will be ignored.",
            "title": ":mod:craftr.defaults"
        },
        {
            "location": "/api/foreignbuild/",
            "text": "craftr.foreignbuild\n\n\n\nconfigure\n\n\n\nconfigure(filename='configure', args=(), cwd=None, env=None, show_output=False)\n\n\n\n\nRun a GNU autotools \nconfigure\n script. If \ncwd\n is not specified, the\ncurrent working directory will be the parent directory of \nfilename\n.\nThis function will skip invokation of the configure script if arguments\nand environment haven't change since the last time.\n\n\nmake\n\n\n\nmake(filename='Makefile', *args, cwd=None, inputs=(), outputs=(), name=None)\n\n\n\n\nCreate a target that executes the specified Makefile. If \ncwd\n is not\nspecified, it defaults to the parent directory if \nfilename\n.",
            "title": "foreignbuild"
        },
        {
            "location": "/api/loaders/",
            "text": "craftr.loaders\n\n\n\nexternal_archive\n\n\n\nexternal_archive(*urls, exclude_files=(), directory=None, name=None)\n\n\n\n\nDownloads an archive from the first valid URL and unpacks it into\n\ndirectory\n. Archives with a single directory at the root will be\nextracted from one level below, eliminating that single parent\ndirectory.\n\n\nexclude_files\n can be a list of glob patterns that will be matched\nagainst the arcnames in the archive. Note that to exclude a directory,\na pattern must match all files in that directory.\n\n\nUses :func:\nexternal_file\n to download the archive.\n\n\n:param urls: See :func:\nexternal_file\n\n:param exclude_files: A list of glob patterns.\n:param directory: The directory to unpack the archive to. Defaults\n    to a directory on the build directory derived from the downloaded\n    archive filename. If defined and followed by a trailing slash, the\n    archive filename will be appended.\n:param name: The name of the loader action. This name is used to store\n    information in the :attr:\nSession.cache\n so we can re-use existing\n    downloaded data. :func:\n~craftr.defaults.gtn\n will be used to\n    retrieve the default value for this parameter.\n:return: The path to the top-level directory of the unpacked archive.\n\n\nexternal_file\n\n\n\nexternal_file(*urls, filename=None, directory=None, copy_file_url=False, name=None)\n\n\n\n\nDownloads a file from the first valid URL and saves it into \ndirectory\n\nunder the specified \nfilename\n.\n\n\n:param urls: One or more URLs. Supports \nhttp://\n, \nhttps://\n,\n    \nftp://\n and \nfile://`. Note that if a\nfile://\nURL is\n    specified, the file is not copied to the output filename unless\n    *copy_file_url* is True.\n:param filename: The output filename of the downloaded file. Defaults\n    to the filename of the downloaded file.\n:param directory: The directory to save the file to. If *filename*\n    is a relative path, it will be joined with this directory. Defaults\n    to a path in the build directory.\n:param copy_file_url: If True,\nfile://\n` URLs will be copied instead\n    of used as-is.\n:param name: The name of the loader action. This name is used to store\n    information in the :attr:\nSession.cache\nso we can re-use existing\n    downloaded data. :func:\n~craftr.defaults.gtn` will be used to\n    retrieve the default value for this parameter.\n:return: The path to the downloaded file.",
            "title": "loaders"
        },
        {
            "location": "/api/targetbuilder/",
            "text": "craftr.targetbuilder\n\n\n\n:mod:\ncraftr.targetbuilder\n\n\nProvides the :class:\nTargetBuilder\n and :class:\nFramework\n classes.\n\n\nget_full_name\n\n\n\nget_full_name(target_name, module=None, module_name=None, version=None)\n\n\n\n\nGiven a \ntarget_name\n, this function generates the fully qualified name of\nthat target that includes the \nmodule\n name and version. If \nmodule\n is\nomitted, the currently executed module is used.\n\n\ngtn\n\n\n\ngtn(target_name=None, name_hint=NotImplemented)\n\n\n\n\nThis function is mandatory in combination with the :class:\nTargetBuilder\n\nclass to ensure that the correct target name can be deduced. If the\n\ntarget_name\n parmaeter is specified, it is returned right away. Otherwise,\nif it is :const:\nNone\n, :func:\nget_assigned_name\n will be used to retrieve\nthe variable name of the expression of 2 frames above this call.\n\n\nTo visualize the behaviour, imagine you are using a target generator function\nlike this:\n\n\n.. code:: python\n\n\nobjects = cxx_compile(\n  srcs = glob(['src/*.cpp'])\n)\n\n\n\n\nThe \ncxx_compile()\n function would use the :class:\nTargetBuilder\n\nsimilar to what is shown below.\n\n\n.. code:: python\n\n\nbuilder = TargetBuilder(inputs, frameworks, kwargs, name = gtn(name))\n\n\n\n\nAnd the :func:\ngtn\n function will use the frame that \ncxx_compile()\n was\ncalled from to retrieve the name of the variable \"objects\". In the case that\nan explicit target name is specified, it will gracefully return that name\ninstead of figuring the name of the assigned variable.\n\n\nIf \nname_hint\n is :const:\nNone\n and no assigned name could be determined,\nno exception will be raised but also no alternative target name will\nbe generated and :const:\nNone\n will be returned. This is useful for wrapping\nexisting target generator functions.\n\n\nTargetBuilder\n\n\n\nTargetBuilder(name, option_kwargs=None, frameworks=(), inputs=(), outputs=(), implicit_deps=(), order_only_deps=())\n\n\n\n\nThis is a helper class for target generators that does a lot of convenience\nhandling such as creating a :class:\nOptionMerge\n from the build options\nspecified with the \nframeworks\n argument or from the input\n:class:\nTargets<build.Target>\n.\n\n\n:param name: The name of the target. Derive this target name by using\n  the :func:\ngtn\n function.\n:param option_kwargs: A dictionary of additional call-level options\n  that have been passed to the target generator function. These will\n  take top priority in the :class:\nOptionMerge\n.\n:param inputs: A list of input files or :class:\nbuild.Target\n objects\n  from which the outputs will be used as input files and the build\n  options will be included in the :class:\nOptionMerge\n.\n:param frameworks: A list of build :class:\nFramework\n objects that will be\n  included in the :class:\nOptionMerge\n.\n:param outputs: A list of output filenames.\n:param implicit_deps: A list of filenames added as implicit dependencies.\n:param order_only_deps: A list of filenames added as order only dependencies.\n\n\nbuild\n\n\n\nTargetBuilder.build(commands, inputs=(), outputs=(), implicit_deps=(), order_only_deps=(), metadata=None, **kwargs)\n\n\n\n\nCreate a :class:\nbuild.Target\n from the information in the builder,\nadd it to the build graph and return it.\n\n\nOptionMerge\n\n\n\nOptionMerge(*frameworks)\n\n\n\n\nThis class represents a virtual merge of :class:\nFramework\n objects. Keys\nin the first dictionaries passed to the constructor take precedence over the\nlast.\n\n\n:param frameworks: One or more :class:\nFramework\n objects. Note that\n  the constructor will expand and flatten the \n'frameworks'\n list.\n\n\nget_list\n\n\n\nOptionMerge.get_list(key)\n\n\n\n\nThis function returns a concatenation of all list values saved under the\nspecified \nkey\n in all option dictionaries in this OptionMerge object.\nIt gives an error if one option dictionary contains a non-sequence for\n\nkey\n.\n\n\nFramework\n\n\n\nFramework(_Framework__name=None, **kwargs)\n\n\n\n\nA framework is simply a dictionary with a name to identify it. Frameworks\nare used to represent build options.",
            "title": "targetbuilder"
        },
        {
            "location": "/api/targetbuilder/#modcraftrtargetbuilder",
            "text": "Provides the :class: TargetBuilder  and :class: Framework  classes.",
            "title": ":mod:craftr.targetbuilder"
        },
        {
            "location": "/changes/",
            "text": "development\n\n\nBugfixes\n\n\n\n\nAn empty value for an option of type \npath\n will no longer end up have the\n  value of the project directory but instead be an empty string\n\n\nFix \nmsvc_runtime_library\n parameter in compile procedure of the\n  \ncraftr.lang.cxx.msvc\n module (invert behaviour of \n'static'\n and \n'dynamic'\n)\n\n\nFix issue with curl and curlpp modules where the object files are not built\n  in the build directory but instead in the source directory, or raise an\n  exception on Windows if the module directory and the build directory are on\n  different drives\n\n\n\n\nBehaviour Changes\n\n\n\n\nExplicit targets now also export a phony target rule in Ninja.\n\n\n\n\nAPI Changes\n\n\n\n\nchange \nload()\n now accepts a \nmode\n parameter instead of \nget_namespace\n,\n  can be one of \n'exports'\n (defualt), \n'namespace'\n and \n'mmodule'\n\n\nadd \ngentask(explicit)\n parameter\n\n\nadd \nenv\n parameter to \nshell.run()\n and \nshell.pipe()\n\n\nadd \ncraftr.foreignbuild\n module\n\n\n\n\nStandard Library\n\n\n\n\nadd \ncraftr.utils.archive\n module\n\n\ncraftr.lang.cxx.msvc\n can now compile ASM code to some extend\n\n\nadd \ncompile_asm()\n to \ncraftr.lang.cxx\n\n\n\n\nCommand-line Changes\n\n\n\n\nadd \n--pm\n option to enable the post-mortem debugger when an exception\n  occurs and is uncaught by the Craftr runtime\n\n\n\n\nv2.0.0.dev7\n\n\nBugfixes\n\n\n\n\nFix function \ncxx_extend_framework()\n that is kept for backwards compatibility,\n  which was missing to call the new \ncxx.extend_framework()\n.\n\n\nFix \nNameError\n in \n'craftr build'\n command\n\n\nfix \nerrno.ENOTTY\n raised on Linux CI runners (eg. GitLab)\n\n\n\n\nChanges\n\n\n\n\nIf terminal size can not be determined, assume 120 characters wide\n  instead of 80\n\n\n\n\nv2.0.0.dev6\n\n\nGeneral Changes\n\n\n\n\nDefault manifest configuration format is now CSON (\nmanifest.cson\n),\n  JSON being kept for backwards compatibility (see #168)\n\n\nFix crash on Travis CI with \ntty.terminal_size()\n (see #169)\n\n\nAdd \ncraftr lock\n command which generates \n.dependency-lock\n file in the\n  same directory as the project's Manifest (see #155)\n\n\n\n\nAPI Changes\n\n\n\n\nadd \npkg_config(static = False)\n parameter\n\n\nadd \npkg_config()\n, \nexternal_file()\n and \nexternal_archive()\n to \ncraftr/defaults.py\n\n\nadd \nglob(ignore_false_excludes=False)\n parameter\n\n\nadd \nBaseLogger.flush()\n method\n\n\nadd \ncraftr.utils.path.getmtime()\n and \n.getimtime()\n\n\nadd \nwrite_response_file(suffix='')\n parameter\n\n\nadd \nDefault\n singleton to built-in namespace\n\n\nadd \ngentask()\n and \ntask()\n built-in functions (see #163)\n\n\nadd \nTarget.runprefix\n parameter and attribute\n\n\nadd \nSession.main_module\n member\n\n\nadd \nModule.dependencies\n member\n\n\nchange \nTarget\n objects can now be passed to the \nframeworks = [...]\n argument\n  of target generators that use the \nTargetBuilder\n class. These input targets\n  will automatically added to the implicit dependencies and their frameworks\n  be added\n\n\nchange \nTool\n objects can now be passed into the \ncommands = [[...]]\n argument\n  of targets generators\n\n\nchange \nruntarget()\n to take \nTarget.runprefix\n into account\n\n\nchange \npath.norm()\n now makes sure that path is lowercased on Windows\n\n\nchange \nload_file()\n now adds the loaded file to \nModule.dependent_files\n\n\nchange \nglob(patterns)\n now accepts a string additionally to a list of strings\n\n\nrename \nload_module()\n to \nload()\n, using the old name displays a warning\n\n\n\n\nLibrary Changes\n\n\n\n\nadd \ncraftr.lib.sdl2\n (tested on Windows only)\n\n\nadd \ncraftr.lib.zlib\n (tested on Windows only)\n\n\nadd \nuic()\n and \nmoc()\n target generators to \ncraftr.lib.qt5\n (tested on Windows only)\n\n\nadd support for \nsource_directory\n argument in \ncxx.c_compile()\n and \ncxx.cpp_compile()\n\n  (actually implemented in \ncraftr.lang.cxx.common\n and \ncraftr.lang.cxx.msvc\n), see #154\n\n\nadd \ncraftr.lang.csharp:compile()\n to be used for unstarred import, and add docstrings\n\n\nadd \nexflags\n option to \ncraftr.lang.cxx.common\n module (see #152)\n\n\nadd \nccprefix\n option to \ncraftr.lang.cxx.common\n module (related to #149)\n\n\nadd to \ncraftr.lang.cxx\n functions \nstatic_library()\n and \nshared_library()\n\n\nchange \ncraftr.lang.cxx\n member names, old names are still available with a\n  deprecation notice. \nbinary() -> executable()\n, \nc_compile() -> compile_c()\n,\n  \ncpp_compile() -> compile_cpp()\n\n\nchange \ncraftr.lib.cURLpp\n always requires RTTI enabled\n\n\nchange \ncraftr.lang.cxx.msvc\n now adds the static input library generated for DLLs to the outputs\n\n\nchange MSVC \ncompile()\n now supports response-files for long list of includes\n\n\nupdate default download version of \ncraftr.lib.zlib\n to \n1.2.10\n\n\n\n\nBehaviour Changes\n\n\n\n\nExperimental change not raising an exception in \ncraftr/core/build.py\n inside\n  \nreplace_argument_inout_vars()\n when multiple outputs are specified to support\n  the previously mentioned change\n\n\nUpdate verbose logging behaviour when the same module was detected twice\n\n\nBuild-directory is now removed again if nothing was exported (eg. when\n  using \ncraftr build\n without formerly exporting the build files)\n\n\nOutput before Ninja is executed is now flushed to make sure all data is\n  flushed to the terminal before Ninja outputs to the pipe\n\n\nWhen using \ncraftr build\n, Craftr now checks if any of the files that generated\n  the build data (ie. manifests and Craftrfiles) have changed since the build\n  files was generated and notifies the user in that case (see #162)\n\n\ncraftr.core.logging.DefaultLogger\n now logs the module and line number from\n  which the log occurred, padded to the right side of the terminal\n\n\nCraftr now exports a variable \nCraftr_run_command\n into the Ninja manifest\n\n\nFix invalid Ninja manifests generated with foreach Targets with no inputs (see #151)\n\n\n\n\nInternal API Changes\n\n\n\n\nadd \ncraftr.core.session.Module.current_line\n property\n\n\nadd \nModule.scriptfile\n property\n\n\nadd \nModule.dependent_files\n attribute\n\n\nadd \nManifest.filename\n attribute\n\n\nadd \ncraftr.core.build.Graph.add_task()\n and \n.tasks\n members\n\n\nadd \ncraftr.core.build.Task\n class\n\n\nadd \ntty.terminal_size(default)\n parameter\n\n\nchange \nManifest.parse()\n no longer accepts a file-like object\n\n\n\n\nCommand-line Changes\n\n\n\n\nadd \n-P/--project-dir\n parameters to \ncraftr\n\n\nadd \ncraftr options [-m MODULE] [-r] [-d]\n command (see #166)\n\n\nadd \ncraftr deptree [-m MODULE]\n command (see #166)\n\n\nadd \ncraftr help [name]\n command (see #167)\n\n\nfix \ncraftr run\n command\n\n\nadd \n[task] [task_args...]\n arguments to \ncraftr run\n (for internal use mostly)",
            "title": "Changelog"
        },
        {
            "location": "/changes/#development",
            "text": "Bugfixes   An empty value for an option of type  path  will no longer end up have the\n  value of the project directory but instead be an empty string  Fix  msvc_runtime_library  parameter in compile procedure of the\n   craftr.lang.cxx.msvc  module (invert behaviour of  'static'  and  'dynamic' )  Fix issue with curl and curlpp modules where the object files are not built\n  in the build directory but instead in the source directory, or raise an\n  exception on Windows if the module directory and the build directory are on\n  different drives   Behaviour Changes   Explicit targets now also export a phony target rule in Ninja.   API Changes   change  load()  now accepts a  mode  parameter instead of  get_namespace ,\n  can be one of  'exports'  (defualt),  'namespace'  and  'mmodule'  add  gentask(explicit)  parameter  add  env  parameter to  shell.run()  and  shell.pipe()  add  craftr.foreignbuild  module   Standard Library   add  craftr.utils.archive  module  craftr.lang.cxx.msvc  can now compile ASM code to some extend  add  compile_asm()  to  craftr.lang.cxx   Command-line Changes   add  --pm  option to enable the post-mortem debugger when an exception\n  occurs and is uncaught by the Craftr runtime",
            "title": "development"
        },
        {
            "location": "/changes/#v200dev7",
            "text": "Bugfixes   Fix function  cxx_extend_framework()  that is kept for backwards compatibility,\n  which was missing to call the new  cxx.extend_framework() .  Fix  NameError  in  'craftr build'  command  fix  errno.ENOTTY  raised on Linux CI runners (eg. GitLab)   Changes   If terminal size can not be determined, assume 120 characters wide\n  instead of 80",
            "title": "v2.0.0.dev7"
        },
        {
            "location": "/changes/#v200dev6",
            "text": "General Changes   Default manifest configuration format is now CSON ( manifest.cson ),\n  JSON being kept for backwards compatibility (see #168)  Fix crash on Travis CI with  tty.terminal_size()  (see #169)  Add  craftr lock  command which generates  .dependency-lock  file in the\n  same directory as the project's Manifest (see #155)   API Changes   add  pkg_config(static = False)  parameter  add  pkg_config() ,  external_file()  and  external_archive()  to  craftr/defaults.py  add  glob(ignore_false_excludes=False)  parameter  add  BaseLogger.flush()  method  add  craftr.utils.path.getmtime()  and  .getimtime()  add  write_response_file(suffix='')  parameter  add  Default  singleton to built-in namespace  add  gentask()  and  task()  built-in functions (see #163)  add  Target.runprefix  parameter and attribute  add  Session.main_module  member  add  Module.dependencies  member  change  Target  objects can now be passed to the  frameworks = [...]  argument\n  of target generators that use the  TargetBuilder  class. These input targets\n  will automatically added to the implicit dependencies and their frameworks\n  be added  change  Tool  objects can now be passed into the  commands = [[...]]  argument\n  of targets generators  change  runtarget()  to take  Target.runprefix  into account  change  path.norm()  now makes sure that path is lowercased on Windows  change  load_file()  now adds the loaded file to  Module.dependent_files  change  glob(patterns)  now accepts a string additionally to a list of strings  rename  load_module()  to  load() , using the old name displays a warning   Library Changes   add  craftr.lib.sdl2  (tested on Windows only)  add  craftr.lib.zlib  (tested on Windows only)  add  uic()  and  moc()  target generators to  craftr.lib.qt5  (tested on Windows only)  add support for  source_directory  argument in  cxx.c_compile()  and  cxx.cpp_compile() \n  (actually implemented in  craftr.lang.cxx.common  and  craftr.lang.cxx.msvc ), see #154  add  craftr.lang.csharp:compile()  to be used for unstarred import, and add docstrings  add  exflags  option to  craftr.lang.cxx.common  module (see #152)  add  ccprefix  option to  craftr.lang.cxx.common  module (related to #149)  add to  craftr.lang.cxx  functions  static_library()  and  shared_library()  change  craftr.lang.cxx  member names, old names are still available with a\n  deprecation notice.  binary() -> executable() ,  c_compile() -> compile_c() ,\n   cpp_compile() -> compile_cpp()  change  craftr.lib.cURLpp  always requires RTTI enabled  change  craftr.lang.cxx.msvc  now adds the static input library generated for DLLs to the outputs  change MSVC  compile()  now supports response-files for long list of includes  update default download version of  craftr.lib.zlib  to  1.2.10   Behaviour Changes   Experimental change not raising an exception in  craftr/core/build.py  inside\n   replace_argument_inout_vars()  when multiple outputs are specified to support\n  the previously mentioned change  Update verbose logging behaviour when the same module was detected twice  Build-directory is now removed again if nothing was exported (eg. when\n  using  craftr build  without formerly exporting the build files)  Output before Ninja is executed is now flushed to make sure all data is\n  flushed to the terminal before Ninja outputs to the pipe  When using  craftr build , Craftr now checks if any of the files that generated\n  the build data (ie. manifests and Craftrfiles) have changed since the build\n  files was generated and notifies the user in that case (see #162)  craftr.core.logging.DefaultLogger  now logs the module and line number from\n  which the log occurred, padded to the right side of the terminal  Craftr now exports a variable  Craftr_run_command  into the Ninja manifest  Fix invalid Ninja manifests generated with foreach Targets with no inputs (see #151)   Internal API Changes   add  craftr.core.session.Module.current_line  property  add  Module.scriptfile  property  add  Module.dependent_files  attribute  add  Manifest.filename  attribute  add  craftr.core.build.Graph.add_task()  and  .tasks  members  add  craftr.core.build.Task  class  add  tty.terminal_size(default)  parameter  change  Manifest.parse()  no longer accepts a file-like object   Command-line Changes   add  -P/--project-dir  parameters to  craftr  add  craftr options [-m MODULE] [-r] [-d]  command (see #166)  add  craftr deptree [-m MODULE]  command (see #166)  add  craftr help [name]  command (see #167)  fix  craftr run  command  add  [task] [task_args...]  arguments to  craftr run  (for internal use mostly)",
            "title": "v2.0.0.dev6"
        },
        {
            "location": "/faq/",
            "text": "FAQ\n\n\nHow to use an alternative Ninja command?\n\n\nYou can set the \ncraftr.ninja\n option or use the \nNINJA\n environment variable.\n\n\n$ craftr -d craftr.ninja=ninja-1.7.2 build\n\n\n\n\nIs there a way to create a Python function that is called from Ninja?\n\n\nSee the Documentation about \nTasks\n.\n\n\nHow can I include a configuration file from another configuration file?\n\n\nYou can use the \n[include \"path/to/config\" if-exists]\n section directive. Note\nthat the \nif-exists\n part is optional.\n\n\nHow can I set a global option in a configuration file?\n\n\nYou can add the options under the \n[__global__]\n section.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/faq/#how-to-use-an-alternative-ninja-command",
            "text": "You can set the  craftr.ninja  option or use the  NINJA  environment variable.  $ craftr -d craftr.ninja=ninja-1.7.2 build",
            "title": "How to use an alternative Ninja command?"
        },
        {
            "location": "/faq/#is-there-a-way-to-create-a-python-function-that-is-called-from-ninja",
            "text": "See the Documentation about  Tasks .",
            "title": "Is there a way to create a Python function that is called from Ninja?"
        },
        {
            "location": "/faq/#how-can-i-include-a-configuration-file-from-another-configuration-file",
            "text": "You can use the  [include \"path/to/config\" if-exists]  section directive. Note\nthat the  if-exists  part is optional.",
            "title": "How can I include a configuration file from another configuration file?"
        },
        {
            "location": "/faq/#how-can-i-set-a-global-option-in-a-configuration-file",
            "text": "You can add the options under the  [__global__]  section.",
            "title": "How can I set a global option in a configuration file?"
        },
        {
            "location": "/projects/",
            "text": "Projects using Craftr\n\n\nNiklasRosenstein.cpp-nr\n\n\nA simple C++ library with various components, complete with tests, benchmarks,\nexamples and continous integration. Demonstrates how to use Google Test and\nGoogle Benchmark and how to implement a re-usable Craftr package. The library\ncan easily be used by using its Craftr Framework.\n\n\ncxx = load('craftr.lang.cxx')\ncpp_nr = load('NiklasRosenstein.cpp-nr').nr\n\nmain = cxx.executable(\n  output = 'main',\n  inputs = cxx.compile_cpp(\n    sources = glob('src/*.cpp'),\n    frameworks = [cpp_nr]\n  )\n)\n\n\n\n\nNiklasRosenstein.maxon.c4d\n\n\nA Craftr package that allows you to build C++ plugins for \nMAXON Cinema 4D\n on\nWindows, macOS and Linux.",
            "title": "Projects using Craftr"
        },
        {
            "location": "/projects/#projects-using-craftr",
            "text": "",
            "title": "Projects using Craftr"
        },
        {
            "location": "/projects/#niklasrosensteincpp-nr",
            "text": "A simple C++ library with various components, complete with tests, benchmarks,\nexamples and continous integration. Demonstrates how to use Google Test and\nGoogle Benchmark and how to implement a re-usable Craftr package. The library\ncan easily be used by using its Craftr Framework.  cxx = load('craftr.lang.cxx')\ncpp_nr = load('NiklasRosenstein.cpp-nr').nr\n\nmain = cxx.executable(\n  output = 'main',\n  inputs = cxx.compile_cpp(\n    sources = glob('src/*.cpp'),\n    frameworks = [cpp_nr]\n  )\n)",
            "title": "NiklasRosenstein.cpp-nr"
        },
        {
            "location": "/projects/#niklasrosensteinmaxonc4d",
            "text": "A Craftr package that allows you to build C++ plugins for  MAXON Cinema 4D  on\nWindows, macOS and Linux.",
            "title": "NiklasRosenstein.maxon.c4d"
        }
    ]
}