# craftr_module(java)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
''' This module provides you with rules to create targets for Java projects. '''

import os


def get_class_names(filenames, base_dir):
  classes = rmvsuffix(move(filenames, base_dir, ''))
  return [x.replace(os.sep, '.') for x in classes]


class JavaC(Translator):

  def _translate_classes_100program(self, program='javac', **kwargs):
    self.result.program = program

  def _translate_classes_500trivial(self, debug=False, nowarn=False,
      verbose=False, deprecation=False, classpath=(), encoding=None,
      Werror=False, options_file=None, Xlint=None, Xdoclint=False,
      obj_dir=None, **kwargs):
    if debug:
      self.result.command += ['-g']
    if nowarn:
      self.result.command += ['-nowarn']
    if verbose:
      self.result.command += ['-verbose']
    if deprecation:
      self.result.command += ['-deprecation']
    if classpath:
      self.result.command += autoexpand(('-classpath', x) for x in classpath)
    if encoding:
      self.result.command += ['-encoding', encoding]
    if Werror:
      self.result.command += ['-Werror']
    if options_file:
      self.result.command += ['@{}'.format(options_file)]
    if Xlint:
      if isinstance(Xlint, (tuple, list)):
        self.result.command += ['-Xlint:{}'.format(','.join(Xlint))]
      elif isinstance(Xlint, str):
        self.result.command += ['-Xlint:{}'.format(Xlint)]
      else:
        self.result.command += ['-Xlint']
    if Xdoclint:
      self.result.command += ['-Xdoclint']
    if obj_dir:
      self.result.command += ['-d', obj_dir]

  def _translate_classes_900infiles(self, **kwargs):
    self.result.command += ['%%in']

  def classes(self, sources, src_dir, obj_dir=None, module=None, **kwargs):
    module = get_calling_module(module)
    objects = addsuffix(rmvsuffix(sources), '.class')
    if obj_dir is not None:
      objects = move(objects, src_dir, obj_dir)
    return module.target(
      inputs=sources,
      outputs=objects,
      command=self.translate('_classes', obj_dir=obj_dir, **kwargs),
      meta_type='java_classes',
      meta_java_classes=get_class_names(sources, src_dir),
    )

  def _translate_jar_100program(self, obj_dir, classes, program='jar',
      manifest=None, no_manifest=False, normalise_pack200=False,
      no_compression=False, entry_point=None, additional_flags='', **kwargs):
    self.result.program = program
    if manifest:
      additional_flags += 'm'
    if normalise_pack200:
      additional_flags += 'n'
    if entry_point:
      additional_flags += 'e'
    if no_compression:
      additional_flags += '0'
    if no_manifest:
      additional_flags += 'M'
    self.result.command += ['cvf' + additional_flags, '%%out']
    if manifest:
      self.result.implicit_deps += [manifest]
      self.result.command += [manifest]
    if entry_point:
      self.result.command += [entry_point]
    self.result.command += ['-C', obj_dir]
    self.result.command += move(classes, obj_dir, '')

  def jar(self, obj_dir, classes, filename, module=None, **kwargs):
    module = get_calling_module(module)
    result = self.translate('_jar', obj_dir=obj_dir, classes=classes, **kwargs)

    return module.target(
      inputs=classes,
      outputs=filename,
      requires=result.implicit_deps,
      command=result,
    )


javac = JavaC()
classes = javac.classes
jar = javac.jar
