# craftr_module(compiler.clang)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import re
import craftr

_base = load_module('compiler.base')


class Archiver(_base.BaseArchiver):

  command = ['ar', 'rcs', '%%out']


class CCompiler(_base.BaseCompiler):

  name = 'Clang'
  command = 'clang'
  archiver = Archiver

  def detect(self, silent=False):
    if self.version:
      return True  # already detected

    try:
      p = Process([self.command, '--version'])
    except (Process.ExitCodeError, OSError) as exc:
      if silent:
        return False
      message = '{} could not be detected on your system. ({})'
      error(message.format(self.name, exc))

    # Clang could be a GCC synonym and the other way round.
    # Check for the GCC version first.
    mv = re.search('gcc version ([\d\.]+)', p.stderr)
    mt = re.search('Target: (\w+)', p.stderr)
    if mv and mt:
      self.name = 'GCC'
      self.version = mv.group(1)
      self.arch = mt.group(1)
      return True

    # Check Clang version.
    mv = re.search('LLVM version ([\d\.]+)', p.stdout)
    mt = re.search('Target: (\w+)', p.stdout)
    if mv and mt:
      self.name = 'Clang'
      self.version = mv.group(1)
      self.arch = mt.group(1)
      return True

    if silent:
      return False
    message = '{} version and architecture could not be detected.'
    error(message.format(self.name))

  def out(self, type_):
    if type_ == 'object':
      return ['-c', '-o', '%%out']
    elif type_ == 'shared_library':
      return ['-dynamiclib', '-o', '%%out']
    elif type_ == 'executable':
      return ['-o', '%%out']
    else:
      raise ValueError('invalid output type {!r}'.format(type_))

  def exceptions(self, enabled):
    if not enabled:
      return '-fno-exceptions'
    return None

  def warn(self, level):
    if level == 'all':
      return '-Wall'
    elif not level or level == 'none':
      return '-w'
    elif 1 <= level <= 4:
      return '-W{:d}'.format(level)
    else:
      raise ValueError('invalid warn level {!r}'.format(level))

  def std(self, std_name):
    # XXX: Raise a ValueError if an invalid std_name is passed.
    return '-std={}'.format(std_name)

  def target(self, arch):
    return ('-arch', arch)

  def l(self, names):
    return ['-l{}'.format(x) for x in names]

  def L(self, paths):
    return ['-L{}'.format(x) for x in names]

  def I(self, paths):
    return ['-I{}'.format(x) for x in paths]

  def D(self, defines):
    return ['-D{}'.format(x) for x in defines]


class CxxCompiler(CCompiler):

  command = 'clang++'
