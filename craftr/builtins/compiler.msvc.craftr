# craftr_module(compiler.msvc)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import re

P = load_module('platform')
_base = load_module('compiler.base')


class Archiver(_base.BaseArchiver):

  command = ['lib', '/nologo', '/OUT:%%out']


class CCompiler(_base.BaseCompiler):

  name = 'MSVC'
  command = 'cl'
  nologo = '/nologo'
  archiver = Archiver

  def detect(self, silent=False):
    if self.version:
      return True  # already detected

    try:
      p = Process([self.command, '/?'])
    except (Process.ExitCodeError, OSError) as exc:
      if silent:
        return False
      error('MSVC Compiler could not be detected. ({})'.format(exc))

    m = re.search('compiler\s+version\s*([\d\.]+)\s*for\s*(\w+)', p.stderr, re.I)
    if not m:
      if silent:
        return False
      error('MSVC Compiler could not be detected. (unexpected output)')

    self.version = m.group(1)
    self.arch = m.group(2)
    return True

  def out(self, type_):
    if type_ == 'object':
      return '/Fo%%out'
    elif type_ == 'executable':
      return '/Fe%%out'
    elif type_ == 'shared_library':
      # XXX: How to specify the output file name correctly?
      if self.debug:
        return ['/LDD', '/OUT:%%out']
      else:
        return ['/LD', '/OUT:%%out']
    else:
      raise ValueError('invalid output type {!r}'.format(type_))

  def exceptions(self, enabled):
    if enabled:
      return '/EHsc'
    return None

  def warn(self, level):
    if level == 'all':
      return '/Wall'
    elif not level or level == 'none':
      return '/w'
    elif 1 <= level <= 4:
      return '/W{:d}'.format(level)
    else:
      raise ValueError('invalid warn level {!r}'.format(level))

  def std(self, std_name):
    warn('MSVC does not support overriding the language standard.')
    return None

  def target(self, arch):
    if not self.arch or self.arch != arch:
      raise ValueError('MSVC does not support changing the output architecture')
    return None

  def l(self, names):
    return names

  def L(self, paths):
    return ['/L{}'.format(x) for x in names]

  def I(self, paths):
    return ['/I{}'.format(x) for x in paths]

  def D(self, defines):
    return ['/D{}'.format(x) for x in defines]


CxxCompiler = CCompiler
