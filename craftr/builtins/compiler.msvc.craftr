# craftr_module(compiler.msvc)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import re

P = load_module('platform')
_base = load_module('compiler.base')


class CCompiler(_base.BaseCompiler):

  name = 'MSVC'
  program = 'cl'

  def detect(self, silent=False):
    if self.version:
      return True  # already detected

    try:
      p = Process(['cl', '/?'])
    except (Process.ExitCodeError, OSError) as exc:
      if silent:
        return False
      error('MSVC Compiler could not be detected. ({})'.format(exc))

    m = re.search('compiler\s+version\s*([\d\.]+)\s*for\s*(\w+)', p.stderr, re.I)
    if not m:
      if silent:
        return False
      error('MSVC Compiler could not be detected. (unexpected output)')

    self.version = m.group(1)
    self.arch = m.group(2)
    return True

  def get_file_type(self, fn):
    if fn.endswith('.obj'):
      return 'object'
    elif fn.endswith('.lib'):
      return 'static_library'
    elif fn.endswith('.dll'):
      return 'shared_library'
    elif fn.endswith('.exe'):
      return 'executable'
    else:
      return None

  def flags(self, output_type, debug=None, exceptions=None, includes=(),
      defines=(), libs=(), link_with=(), external_libs=(), ldpaths=(),
      additional_flags=(), warning_level=None, std=None, arch=None, lang=None,
      **options):
    ''' Generate flags based on the specfied options. '''

    result = []

    if arch is not None:
      if getattr(self, 'arch', None) != arch:
        self.invalid_option('arch', arch)

    if output_type == 'object':
      # Options that only need to be set when compiling a source file.

      if debug:
        result += ['/Od', '/Zi']

      if exceptions is not None and exceptions:
        result += ['/EHsc']

      if warning_level is not None:
        if warning_level == 'all':
          result += ['/Wall']
        elif warning_level in (0, 'none'):
          result += ['/w']
        elif 1 <= warning_level <= 4:
          result += ['/W{}'.format(warning_level)]
        else:
          self.invalid_option('warning_level', warning_level)

      if std is not None:
        # XXX: Allow known standards of MSVC.
        raise ValueError('MSVC has no overridable language standards')

      result.extend('/I{}'.format(x) for x in includes)
      result.extend('/D{}'.format(x) for x in defines)
      result += ['%%in', '/c', '/Fo%%out']

    elif output_type in ('executable', 'shared_library', 'static_library'):

      if debug:
        result += ['/debug']

      def switch_lib(fn):
        if fn.endswith('.dll'):
          fn = addsuffix(rmvsuffix(fn), '.lib')
        return fn

      result.extend(map(switch_lib, libs))
      result.extend(map(switch_lib, external_libs))
      result.extend('/L{}'.format(x) for x in ldpaths)
      result.extend(link_with)

      if output_type == 'executable':
        result += ['/OUT:%%out', '%%in']
      elif output_type == 'shared_library':
        result += ['/DLL', '/OUT:%%out', '%%in']
      elif output_type == 'static_library':
        result += ['/OUT:%%out', '%%in']

    else:
      self.invalid_option('output_type', output_type)

    result.extend(additional_flags)

    return result

  def command(self, output_type, **options):
    if output_type == 'object':
      command = ['cl']
    elif output_type in ('executable', 'shared_library'):
      command = ['link']
    elif output_type == 'static_library':
      command = ['lib']
    else:
      self.invalid_option('output_type', output_type)
    if options.get('nologo', True):
      command.append('/nologo')
    command += self.flags(output_type=output_type, **options)
    return command


CxxCompiler = CCompiler
