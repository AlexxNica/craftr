# craftr_module(compiler.msvc)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
import re
import tempfile

load_module('ninja')
P = load_module('platform')
_base = load_module('compiler.base')


class CCompiler(_base.BaseCompiler):

  name = 'MSVC'

  def init_default_options(self):
    self.options.setdefault('program', 'cl')
    super().init_default_options()

  def detect(self, silent=False):
    if self.version:
      return True  # already detected

    arch = None
    version = None
    msvc_deps_prefix = None
    with tempfile.NamedTemporaryFile(suffix='.cpp', delete=False) as fp:
      # Determine the msvc_deps_prefix by making a small test. The
      # compilation will not succeed since no entry point is defined.
      fp.write(b'#include <stddef.h>\n')
      fp.close()
      try:
        p = Process([self.options['program'], '/Zs', '/showIncludes', fp.name])
      except Process.ExitCodeError as exc:
        p = exc.process
      except OSError as exc:
        if silent:
          return False
        error('MSVC could not be detected ({})'.format(exc))
      finally:
        os.remove(fp.name)

      # Extract the compiler version and architecture from stdout.
      expr = r'compiler\s+version\s*([\d\.]+)\s*for\s*(\w+)'
      match = re.search(expr, p.stderr, re.I)
      if not match:
        if silent:
          return False
        warn(p.stdout)
        error('MSVC version and architecture could not be detected (see above)')

      arch = match.group(2)
      version = match.group(1)

      # Find the "Note: including file:" in the current language. We
      # assume that the structure is the same, only the words different.
      # First line is the name of the file, second line starts the include
      # notices.
      lines = p.stdout.split('\n', 2)
      if len(lines) >= 2:
        match = re.search('[\w\s]+:[\w\s]+:', lines[1])
        if match:
          msvc_deps_prefix = match.group(0)

    # XXX: Ideally, the msvc_deps_prefix could be set on a per-rule basis
    # instead of globally.
    if not msvc_deps_prefix:
      warn('msvc_deps_prefix could not be determined, fallback on english version')
      ninja.msvc_deps_prefix = 'Note: including file:'
    else:
      ninja.msvc_deps_prefix = msvc_deps_prefix

    self.arch = arch
    self.version = version
    self.msvc_deps_prefix = msvc_deps_prefix
    return True

  def get_file_type(self, fn):
    if fn.endswith('.obj'):
      return 'object'
    elif fn.endswith('.lib'):
      return 'static_library'
    elif fn.endswith('.dll'):
      return 'shared_library'
    elif fn.endswith('.exe'):
      return 'executable'
    else:
      return None

  def flags(self, output_type, debug=None, exceptions=None, includes=(),
      defines=(), libs=(), link_with=(), external_libs=(), ldpaths=(),
      additional_flags=(), warning_level=None, std=None, arch=None, lang=None,
      **options):
    ''' Generate flags based on the specfied options. '''

    result = []

    if arch is not None:
      if getattr(self, 'arch', None) != arch:
        self.invalid_option('arch', arch)

    if output_type == 'object':
      # Options that only need to be set when compiling a source file.

      if debug:
        result += ['/Od', '/Zi']

      if exceptions is not None and exceptions:
        result += ['/EHsc']

      if warning_level is not None:
        if warning_level == 'all':
          result += ['/W4']  # /Wall *really* shows a lot of warnings, including no-ops in the standard library
        elif warning_level in (0, 'none'):
          result += ['/w']
        elif 1 <= warning_level <= 4:
          result += ['/W{}'.format(warning_level)]
        else:
          self.invalid_option('warning_level', warning_level)

      if std is not None:
        # XXX: Allow known standards of MSVC.
        raise ValueError('MSVC has no overridable language standards')

      result.extend('/I{}'.format(x) for x in includes)
      result.extend('/D{}'.format(x) for x in defines)
      result += ['%%in', '/c', '/Fo%%out']

    elif output_type in ('executable', 'shared_library', 'static_library'):

      if debug:
        result += ['/debug']

      def switch_lib(fn):
        if fn.endswith('.dll'):
          fn = addsuffix(rmvsuffix(fn), '.lib')
        return fn

      result.extend(map(switch_lib, libs))
      result.extend(map(switch_lib, external_libs))
      result.extend('/L{}'.format(x) for x in ldpaths)
      result.extend(link_with)

      if output_type == 'executable':
        result += ['/OUT:%%out', '%%in']
      elif output_type == 'shared_library':
        result += ['/DLL', '/OUT:%%out', '%%in']
      elif output_type == 'static_library':
        result += ['/OUT:%%out', '%%in']

    else:
      self.invalid_option('output_type', output_type)

    result.extend(additional_flags)

    return result

  def command(self, output_type, **options):
    if output_type == 'object':
      command = ['cl']
    elif output_type in ('executable', 'shared_library'):
      command = ['link']
    elif output_type == 'static_library':
      command = ['lib']
    else:
      self.invalid_option('output_type', output_type)
    if options.get('nologo', True):
      command.append('/nologo')
    command += self.flags(output_type=output_type, **options)
    return command

  def autodeps(self, autodeps=True, depfile=None):
    return {'deps': 'msvc', 'flags': ['/showIncludes']}


CxxCompiler = CCompiler
