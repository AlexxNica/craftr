# -*- mode: python -*-
# Copyright (C) 2015  Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from craftr import *
from craftr.ext.compiler import *
from craftr.ext import platform
import re


def _search(pattern, subject, mode=0):
  ''' Performs `re.search()` and returns a list of the captured groups,
  *including* the complete matched string as the first group. If the
  regex search was unsuccessful, a list with that many items containing
  None is returned. '''

  pattern = re.compile(pattern, mode)
  ngroups = pattern.groups + 1

  res = pattern.search(subject)
  if not res:
    return [None] * ngroups
  else:
    groups = list(res.groups())
    groups.insert(0, res.group(0))
    return groups


def _flatten(iterable):
  for item in iterable:
    yield from item


def detect(program, _mode='llvm'):
  ''' Tries to detect the version information of the LLVM *program*
  by calling it with the `-v` option and returns a dictionary of the
  extracted information. Raises `ToolDetectionError` if the information
  could not be retrieved (eg. if *program* does not exist or is not an
  LLVM or GCC compiler based on *_mode*). '''

  try:
    output = shell.pipe([program, '-v']).output
  except FileNotFoundError as exc:
    raise ValueError(exc)
  if _mode == 'llvm':
    version_str, version  = _search(r'clang\s+version\s+([\d\.\-]+).*$', output, re.I | re.M)
    target = _search(r'Target:\s*([\w\-\._]+)', output, re.I)[1]
    thread_model = _search(r'Thread\s+model:\s*([\w\-\._]+)', output, re.I)[1]
    if not version:
      raise ToolDetectionError('could not determine LLVM version')
  elif _mode == 'gcc':
    version_str, version = _search(r'gcc\s+version\s+([\d\.\-]+).*\s*$', output, re.I)
    target = _search(r'Target:\s*([\w\-\._]+)', output, re.I)[1]
    thread_model = _search(r'--enable-threads=([\w\-\._]+)', output)[1]
    if not version:
      raise ToolDetectionError('could not determine GCC version')
  else:
    raise ValueError('invalid _mode: {0!r}'.format(_mode))

  return {
    'version': version,
    'version_str': version_str.strip(),
    'target': target,
    'thread_model': thread_model,
  }


class LlvmCompiler(BaseCompiler):
  ''' Interface for the LLVM compiler. '''

  name = 'LLVM'

  def __init__(self, program, language, desc=None, **kwargs):
    super().__init__(program=program, language=language, **kwargs)
    if not desc:
      desc = detect(program)
    self.desc = desc
    self.version = desc['version']

  def compile(self, sources, frameworks=(), target_name=None, **kwargs):
    builder = self.builder(sources, frameworks, kwargs, name=target_name)
    objects = gen_objects(builder.inputs, suffix=platform.obj)
    fw = builder.add_framework(builder.name)

    include = set(builder.merge('include'))
    defines = set(builder.merge('defines'))
    language = builder['language']
    debug = builder.get('debug', False)
    std = builder.get('std')
    pedantic = builder.get('pedantic', False)
    pic = builder.get('pic', False)
    warn = builder.get('warn', 'all')
    optimize = builder.get('optimize', None)
    autodeps = builder.get('autodeps', True)
    builder.target['description'] = builder.get('description', 'LLVM Compile Object($out)')

    if platform.name == 'Darwin':
      osx_fwpath = builder.merge('osx_fwpath')
      osx_frameworks = builder.merge('osx_frameworks')
    else:
      osx_fwpath = []
      osx_frameworks = []

    if language not in ('c', 'c++'):
      raise ValueError('invalid language: {0}'.format(language))
    if language == 'c++':
      fw['libs'] = ['c++']

    command = [builder['program'], '-x', language, '-c', '$in', '-o', '$out']
    command += ['-g'] if debug else []
    command += ['-std=' + std] if std else []
    command += ['-pedantic'] if pedantic else []
    command += ['-I' + x for x in include]
    command += ['-D' + x for x in defines]
    command += ['-fPIC'] if pic else []
    command += ['-F' + x for x in osx_fwpath]
    command += _flatten(['-framework', x] for x in osx_frameworks)

    if warn == 'all':
      command += ['-Wall']
    elif warn == 'none':
      command += ['-w']
    elif warn is None:
      pass
    else:
      builder.invalid_option('warn')

    if debug:
      if optimize and optimize != 'debug':
        builder.invalid_option('optimize', cause='no optimize with debug enabled')
    elif optimize == 'speed':
      command += ['-O4']
    elif optimize == 'size':
      commandm += ['-Os']
    elif optimize in ('debug', 'none', None):
      command += ['-O0']
    else:
      builder.invalid_option('optimize')

    if autodeps:
      builder.target['depfile'] = '$out.d'
      builder.target['deps'] = 'gcc'
      command += ['-MMD', '-MF', '$depfile']

    command += builder.merge('additional_flags')

    return builder.create_target(command, outputs=objects, foreach=True)

  def link(self, output, inputs, output_type='bin', frameworks=(), target_name=None, **kwargs):
    builder = self.builder(inputs, frameworks, kwargs, name=target_name)

    if output_type not in ('bin', 'dll'):
      raise ValueError('invalid output_type: {0!r}'.format(output_type))
    output = gen_output(output, suffix=getattr(platform, output_type))

    libs = set(builder.merge('libs'))
    libpath = set(builder.merge('libpath'))
    external_libs = set(builder.merge('external_libs'))

    if platform.name == 'Darwin':
      osx_fwpath = builder.merge('osx_fwpath')
      osx_frameworks = builder.merge('osx_frameworks')
    else:
      osx_fwpath = []
      osx_frameworks = []

    command = [builder['program'], '$in']
    command += ['-l' + x for x in libs]
    command += ['-L' + x for x in libpath]
    command += external_libs
    command += ['-dynamic'] if output_type == 'dll' else []
    command += ['-F' + x for x in osx_fwpath]
    command += _flatten(['-framework', x] for x in osx_frameworks)
    command += builder.merge('additional_flags')
    command += ['-o', '$out']

    return builder.create_target(command, outputs=[output], implicit_deps=external_libs)



Compiler = LlvmCompiler
