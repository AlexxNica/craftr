# -*- mode: python -*-
# Copyright (C) 2015  Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from craftr import *

import collections
import copy


def gen_output(output, subdir=None, suffix=None):
  if isinstance(output, str):
    if not path.isabs(output):
      pdir = path.join(module.project_name, subdir) if subdir else module.project_name
      output = path.join(pdir, output)
    if suffix is not None:
      if callable(suffix):
        output = suffix(output)
      else:
        output = path.addsuffix(output, suffix)
    return output
  elif isinstance(output, collections.Iterable):
    return [gen_output(x, subdir, suffix) for x in output]
  else:
    raise TypeError('expected str or Iterable')


def gen_objects(sources, subdir='obj', suffix=None):
  if not sources:
    return []
  basedir = path.commonpath(sources)
  objects = path.move(sources, basedir, path.join(module.project_name, subdir))
  if suffix is not None:
    if callable(suffix):
      objects = [suffix(path.rmvsuffix(x)) for x in objects]
    else:
      objects = path.setsuffix(objects, suffix)
  return objects


class BaseCompiler(object):
  ''' Base class for implementing a compiler object that can be forked
  with new options and that makes it easy to implement rule methods. '''

  def __init__(self, **kwargs):
    if not hasattr(self, 'name'):
      raise TypeError('{0}.name is not set'.format(type(self).__name__))
    super().__init__()
    self.settings = Framework(type(self).__name__, **kwargs)
    self.frameworks = [self.settings]

  def builder(self, inputs, frameworks, kwargs, **_add_kwargs):
    ''' Creates a `TargetBuilder` that also contains the frameworks of
    this compiler object. '''

    frameworks = self.frameworks + list(frameworks)
    return TargetBuilder(inputs, frameworks, kwargs, stacklevel=2, **_add_kwargs)

  def fork(self, **kwargs):
    ''' Create a fork of the compiler while overriding the *kwargs*. '''

    obj = copy.copy(self)
    # Create a new Settings framework for the compiler.
    obj.settings = Framework(type(self).__name__, **kwargs)
    # Copy the frameworks of the parent.
    obj.frameworks = self.frameworks[:]
    obj.frameworks.append(obj.settings)
    return obj

  def __getitem__(self, key):
    return FrameworkJoin(*self.frameworks)[key]

  def __setitem__(self, key, value):
    self.settings[key] = value


class ToolDetectionError(Exception):
  ''' This exception is raised if a command-line tool could not be
  successfully be detected. '''


__all__ = ['gen_output', 'gen_output', 'BaseCompiler', 'ToolDetectionError']
