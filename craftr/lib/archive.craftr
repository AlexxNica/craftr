# -*- mode: python -*-
# Copyright (C) 2015  Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from craftr import *
from craftr.tty import clear_line
from functools import partial
from fnmatch import fnmatch

import collections
import ctypes
import errno
import sys
import zipfile

if sys.platform.startswith('win32'):
  _is_win32 = True
  def _win32_get_long_path_name(path):
    # Thanks to http://stackoverflow.com/a/3694799/791713
    assert sys.platform.startswith('win32')
    buf = ctypes.create_unicode_buffer(len(path) + 1)
    GetLongPathNameW = ctypes.windll.kernel32.GetLongPathNameW
    res = GetLongPathNameW(path, buf, len(path) + 1)
    if res == 0 or res > 260:
      return path
    else:
      return buf.value
else:
  _is_win32 = False


class Archive(object):
  ''' Helper class to build and a list of files for an archive
  and then create that archive from that list. '''

  File = collections.namedtuple('File', 'name rel_dir arc_name')

  def __init__(self, base_dir = None, prefix = None):
    self._files = []
    self._base_dir = base_dir or module.project_dir
    self._prefix = prefix

  def add(self, name, rel_dir = None, arc_name = None, parts = None):
    ''' Add a file, directory or `Target` to the archive file list.
    If *parts* is specified, it must be a number which specifies how
    many parts of the arc name are kept from the right. '''

    if arc_name and parts:
      raise TypeError('arc_name conflicts with parts')

    def _raise_arc():
      if arc_name:
        raise TypeError('arc_name can only be specified for a single file')

    if not rel_dir:
      rel_dir = self._base_dir
    if isinstance(name, (tuple, list)):
      _raise_arc()
      [self.add(path.abspath(x), rel_dir, None, parts) for x in name]
    elif isinstance(name, str):
      if not path.isabs(name):
        name = path.local(name)
      # xxx: make sure *name* is a subpath of *rel_dir*
      if path.isglob(name):
        _raise_arc()
        self.add(path.glob(name), rel_dir, None, parts)
      elif path.isdir(name):
        _raise_arc()
        self.add(path.glob(path.join(name, '**')), rel_dir, None, parts)
      else:
        if not path.isfile(name):
          raise FileNotFoundError(name)
        if parts:
          assert not arc_name
          path_parts = path.split_path(name)
          arc_name = path.sep.join(path_parts[-parts:])
        if _is_win32:
          name = _win32_get_long_path_name(name)
        self._files.append(Archive.File(name, rel_dir, arc_name))
    else:
      raise TypeError('name must be str/list/tuple')

  def exclude(self, filter):
    ''' Remove all files in the Archive's file list that match the
    specified *filter*. The filter can be a string, in which case it
    is applied with `fnmatch()` or a function which accepts a single
    argument (the filename). '''

    if isinstance(filter, str):
      def wrapper(pattern):
        return lambda x: fnmatch(x, pattern)
      filter = wrapper(filter)

    self._files = [file for file in self._files if not filter(file.name)]

  def save(self, name=None, format='zip'):
    ''' Save the archvie under the specified name. If the name is not
    specfified, the *prefix* must have been passed to the `Archive`
    constructor. The format must be `'zip'` for now. '''

    assert format == 'zip', "format must be 'zip' for now"
    if not name:
      if not self._prefix:
        raise ValueError('no name and no Archive prefix specified')
      name = self._prefix + '.' + format

    zf = zipfile.ZipFile(name, 'w')
    for file in self._files:
      arc_name = file.arc_name or path.relpath(file.name, file.rel_dir)
      zf.write(file.name, arc_name)
